<div class=WordSection3>

<h1><a name="_Toc364255681"><span lang=EN-US>1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Introduction</span></a></h1>

<p class=MsoNormal><span lang=EN-US>Web applications such as e-mail, maps,
document editing, and collaboration tools are becoming an increasingly
important part of the everyday computing. We designed TypeScript to meet the
needs of the JavaScript programming teams that build and maintain large
JavaScript programs such as web applications. TypeScript helps programming
teams to define interfaces between software components and to gain insight into
the behavior of existing JavaScript libraries. TypeScript also enables teams to
reduce naming conflicts by organizing their code into dynamically-loadable
modules. TypeScript’s optional type system enables JavaScript programmers to
use highly-productive development tools and practices: static checking,
symbol-based navigation, statement completion, and code re-factoring.</span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript is a syntactic sugar for
JavaScript. TypeScript syntax is a superset of Ecmascript 5 (ES5) syntax. Every
JavaScript program is also a TypeScript program. The TypeScript compiler
performs only file-local transformations on TypeScript programs and does not
re-order variables declared in TypeScript. This leads to JavaScript output that
closely matches the TypeScript input. TypeScript does not transform variable
names, making tractable the direct debugging of emitted JavaScript. TypeScript
optionally provides source maps, enabling source-level debugging. TypeScript
tools typically emit JavaScript upon file save, preserving the test, edit,
refresh cycle commonly used in JavaScript development.</span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript syntax includes several proposed
features of Ecmascript 6 (ES6), including classes and modules. Classes enable
programmers to express common object-oriented patterns in a standard way,
making features like inheritance more readable and interoperable. Modules
enable programmers to organize their code into components while avoiding naming
conflicts. The TypeScript compiler provides module code generation options that
support either static or dynamic loading of module contents.</span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript also provides to JavaScript
programmers a system of optional type annotations. These type annotations are
like the JSDoc comments found in the Closure system, but in TypeScript they are
integrated directly into the language syntax. This integration makes the code
more readable and reduces the maintenance cost of synchronizing type
annotations with their corresponding variables.</span></p>

<p class=MsoNormal><span lang=EN-US>The TypeScript type system enables
programmers to express limits on the capabilities of JavaScript objects, and to
use tools that enforce these limits. To minimize the number of annotations
needed for tools to become useful, the TypeScript type system makes extensive
use of type inference. For example, from the following statement, TypeScript
will infer that the variable ‘i’ has the type number.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
		lang=EN-US> i = 0;</span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript will infer from the following
function definition that the function f has return type string.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
		lang=EN-US> f() {<br>
    <span style='color:blue;background:white'>return</span> <span
			style='color:maroon;background:white'>&quot;hello&quot;</span>;<br>
}</span></p>

<p class=MsoNormal><span lang=EN-US>To benefit from this inference, a
programmer can use the TypeScript language service. For example, a code editor
can incorporate the TypeScript language service and use the service to find the
members of a string object as in the following screen shot.</span></p>

<p class=MsoNormal style='margin-left:36.0pt'><img width=442 height=297
												   id="Picture 6"
												   src="../TypeScript%20Language%20Specification_bestanden/image001.png"></p>

<p class=MsoNormal><span lang=EN-US>In this example, the programmer benefits
from type inference without providing type annotations. Some beneficial tools,
however, do require the programmer to provide type annotations. In TypeScript,
we can express a parameter requirement as in the following code fragment.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
		lang=EN-US> f(s: <span style='color:blue;background:white'>string</span>) {<br>
    <span style='color:blue;background:white'>return</span> s;<br>
}</span></p>

<p class=Code><span lang=EN-US>f({});       <span style='color:green;
background:white'>// Error</span><br>
f(<span style='color:maroon;background:white'>&quot;hello&quot;</span>);  <span
			style='color:green;background:white'>// Ok</span></span></p>

<p class=MsoNormal><span lang=EN-US>This optional type annotation on the parameter
‘s’ lets the TypeScript type checker know that the programmer expects parameter
‘s’ to be of type ‘string’. Within the body of function ‘f’, tools can assume
‘s’ is of type ‘string’ and provide operator type checking and member
completion consistent with this assumption. Tools can also signal an error on
the first call to ‘f’, because ‘f’ expects a string, not an object, as its
parameter. For the function ‘f’, the TypeScript compiler will emit the
following JavaScript code:</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
		lang=EN-US style='color:black'>&nbsp;f(s)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span lang=EN-US style='color:blue;background:
white'>return</span><span lang=EN-US style='color:black'>&nbsp;s;<br>
}</span></p>

<p class=MsoNormal><span lang=EN-US>In the JavaScript output, all type
annotations have been erased. In general, TypeScript erases all type
information before emiting JavaScript.</span></p>

<h2><a name="_Toc364255682"><span lang=EN-US>1.1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Ambient Declarations</span></a></h2>

<p class=MsoNormal><span lang=EN-US>An ambient declaration introduces a
variable into a TypeScript scope, but has zero impact on the emitted JavaScript
program. Programmers can use ambient declarations to tell the TypeScript
compiler that some other component will supply a variable. For example, by
default the TypeScript compiler will print an error for uses of undefined
variables. To add some of the common variables defined by browsers, a TypeScript
programmer can use ambient declarations. The following example declares the
‘document’ object supplied by browsers. Because the declaration does not
specify a type, the type ‘any’ is inferred. The type ‘any’ means that a tool
can assume nothing about the shape or behavior of the document object. Some of
the examples below will illustrate how programmers can use types to further
characterize the expected behavior of an object.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>declare</span><span
		lang=EN-US> <span style='color:blue;background:white'>var</span> document;<br>
document.title = <span style='color:maroon;background:white'>&quot;Hello&quot;</span>; 
<span style='color:green;background:white'>// Ok</span><span style='color:green'>
because document has been declared</span></span></p>

<p class=MsoNormal><span lang=EN-US>In the case of ‘document’, the TypeScript
compiler automatically supplies a declaration, because TypeScript by default
includes a file ‘lib.d.ts’ that provides interface declarations for the
built-in JavaScript library as well as the Document Object Model.</span></p>

<p class=MsoNormal><span lang=EN-US>The TypeScript compiler does not include by
default an interface for jQuery, so to use jQuery, a programmer could supply a
declaration such as:</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>declare</span><span
		lang=EN-US> <span style='color:blue;background:white'>var</span> $;</span></p>

<p class=MsoNormal><span lang=EN-US>Section </span><span
		lang=EN-US>1.3</span><span lang=EN-US> provides a more extensive example of how
a programmer can add type information for jQuery and other libraries.</span></p>

<h2><a name="_Toc364255683"><span lang=EN-US>1.2<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Function Types</span></a></h2>

<p class=MsoNormal><span lang=EN-US>Function expressions are a powerful feature
of JavaScript. They enable function definitions to create closures: functions
that capture information from the lexical scope surrounding the function’s
definition. Closures are currently JavaScript’s only way of enforcing data
encapsulation. By capturing and using environment variables, a closure can
retain information that cannot be accessed from outside the closure. JavaScript
programmers often use closures to express event handlers and other asynchronous
callbacks, in which another software component, such as the DOM, will call back
into JavaScript through a handler function.</span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript function types make it possible
for programmers to express the expected <i>signature</i> of a function. A
function signature is a sequence of parameter types plus a return type. The
following example uses function types to express the callback signature
requirements of an asynchronous voting mechanism.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
		lang=EN-US> vote(candidate: <span style='color:blue;background:white'>string</span>,
callback: (result: <span style='color:blue;background:white'>string</span>)
=&gt; <span style='color:blue;background:white'>any</span>) {<br>
   <span style='color:green;background:white'>// ...</span><br>
}</span></p>

<p class=Code><span lang=EN-US>vote(<span style='color:maroon;background:white'>&quot;BigPig&quot;</span>,<br>
     <span style='color:blue;background:white'>function</span>(result: <span
			style='color:blue;background:white'>string</span>) {<br>
         <span style='color:blue;background:white'>if</span> (result === <span
			style='color:maroon;background:white'>&quot;BigPig&quot;</span>) {<br>
            <span style='color:green;background:white'>// ...</span><br>
         }<br>
     }<br>
);</span></p>

<p class=MsoNormal><span lang=EN-US>In this example, the second parameter to ‘vote’
has the function type</span></p>

<p class=Code><span lang=EN-US>(result: <span style='color:blue;background:
white'>string</span>) =&gt; <span style='color:blue;background:white'>any</span></span></p>

<p class=MsoNormal><span lang=EN-US>which means the second parameter is a
function returning type ‘any’ that has a single parameter of type ‘string’
named ‘result’.</span></p>

<p class=MsoNormal><span lang=EN-US>Section </span><span
		lang=EN-US>3.7.2</span><span lang=EN-US> provides additional information about
function types.</span></p>

<h2><a name="_Toc364255684"></a><a name="_Ref336337724"><span lang=EN-US>1.3<span
		style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
		lang=EN-US>Object Types</span></a></h2>

<p class=MsoNormal><span lang=EN-US>TypeScript programmers use <i>object types</i>
to declare their expectations of object behavior. The following code uses an <i>object
		type literal</i> to specify the return type of the ‘MakePoint’ function.</span></p>

<p class=Code><span lang=EN-US style='color:blue'>var</span><span lang=EN-US>&nbsp;MakePoint:&nbsp;()&nbsp;=&gt;&nbsp;{<span
		style='color:teal'><br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;x:&nbsp;<span style='color:blue'>number</span>;&nbsp;y:&nbsp;<span
		style='color:blue'>number</span>;<span style='color:teal'><br>
</span>};</span></p>

<p class=MsoNormal><span lang=EN-US>Programmers can give names to object types;
we call named object types <i>interfaces</i>. For example, in the following
code, an interface declares one required field (name) and one optional field
(favoriteColor).</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
		lang=EN-US> Friend {<br>
    name: <span style='color:blue;background:white'>string</span>;<br>
    favoriteColor?: <span style='color:blue;background:white'>string</span>;<br>
}</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
		lang=EN-US> add(friend: Friend) {<br>
    <span style='color:blue;background:white'>var</span> name = friend.name;<br>
}</span></p>

<p class=Code><span lang=EN-US>add({ name: <span style='color:maroon;
background:white'>&quot;Fred&quot;</span> });  <span style='color:green;
background:white'>// Ok</span><br>
add({ favoriteColor: <span style='color:maroon;background:white'>&quot;blue&quot;</span>
});  <span style='color:green;background:white'>// Error, name required</span><br>
add({ name: <span style='color:maroon;background:white'>&quot;Jill&quot;</span>,
favoriteColor: <span style='color:maroon;background:white'>&quot;green&quot;</span>
});  <span style='color:green;background:white'>// Ok</span></span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript object types model the diversity
of behaviors that a JavaScript object can exhibit. For example, the jQuery
library defines an object, ‘$’, that has methods, such as ‘get’ (which sends an
Ajax message), and fields, such as ‘browser’ (which gives browser vendor
information). However, jQuery clients can also call ‘$’ as a function. The
behavior of this function depends on the type of parameters passed to the
function.</span></p>

<p class=MsoNormal><span lang=EN-US>The following code fragment captures a
small subset of jQuery behavior, just enough to use jQuery in a simple way.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
		lang=EN-US> JQuery {<br>
    text(content: <span style='color:blue;background:white'>string</span>);<br>
}<br>
<br>
<span style='color:blue;background:white'>interface</span> JQueryStatic {<br>
    get(url: <span style='color:blue;background:white'>string</span>, callback:
(data: <span style='color:blue;background:white'>string</span>) =&gt; <span
			style='color:blue;background:white'>any</span>);   <br>
    (query: <span style='color:blue;background:white'>string</span>): JQuery;   
<br>
}</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>declare</span><span
		lang=EN-US> <span style='color:blue;background:white'>var</span> $: JQueryStatic;</span></p>

<p class=Code><span lang=EN-US>$.get(<span style='color:maroon;background:white'>&quot;http://mysite.org/divContent&quot;</span>,<br>
      <span style='color:blue;background:white'>function</span> (data: <span
			style='color:blue;background:white'>string</span>) {<br>
          $(<span style='color:maroon;background:white'>&quot;div&quot;</span>).text(data);<br>
      }<br>
);</span></p>

<p class=MsoNormal><span lang=EN-US>The ‘JQueryStatic’ interface references
another interface: ‘JQuery’. This interface represents a collection of one or
more DOM elements. The jQuery library can perform many operations on such a
collection, but in this example the jQuery client only needs to know that it
can set the text content of each jQuery element in a collection by passing a string
to the ‘text’ method. The ‘JQueryStatic’ interface also contains a method,
‘get’, that performs an Ajax get operation on the provided URL and arranges to
invoke the provided callback upon receipt of a response.</span></p>

<p class=MsoNormal><span lang=EN-US>Finally, the ‘JQueryStatic’ interface
contains a bare function signature </span></p>

<p class=Code><span lang=EN-US>(query: <span style='color:blue;background:white'>string</span>):
JQuery;</span></p>

<p class=MsoNormal><span lang=EN-US>The bare signature indicates that instances
of the interface are callable. This example illustrates that TypeScript
function types are just special cases of TypeScript object types. Specifically,
function types are object types that contain only a call signature, but no
properties. For this reason we can write any function type as an object type
literal. The following example uses both forms to describe the same type.</span></p>

<p class=Code><span lang=EN-US style='color:blue'>var</span><span lang=EN-US>&nbsp;f:&nbsp;{&nbsp;():&nbsp;<span
		style='color:blue'>string</span>;&nbsp;};<span style='color:teal'><br>
</span><span style='color:blue'>var</span>&nbsp;sameType:&nbsp;()&nbsp;=&gt;&nbsp;<span
		style='color:blue'>string</span>&nbsp;=&nbsp;f;<span style='color:green'>     //
Ok</span><span style='color:teal'><br>
</span><span style='color:blue'>var</span>&nbsp;nope:&nbsp;()&nbsp;=&gt;&nbsp;<span
		style='color:blue'>number</span>&nbsp;=&nbsp;sameType;&nbsp; <span
		style='color:green'>//&nbsp;Error:&nbsp;type&nbsp;mismatch</span></span></p>

<p class=MsoNormal><span lang=EN-US>We mentioned above that the ‘$’ function
behaves differently depending on the type of its parameter. So far, our jQuery
typing only captures one of these behaviors: return an object of type ‘JQuery’
when passed a string. To specify multiple behaviors, TypeScript supports <i>overloading</i>
of function signatures in object types. For example, we can add an additional
call signature to the ‘JQueryStatic’ interface.</span></p>

<p class=Code><span lang=EN-US>(<span style='color:black'>ready</span>:<span
		style='color:black'>&nbsp;</span>()<span style='color:black'>&nbsp;</span>=&gt;<span
		style='color:black'>&nbsp;</span><span style='color:blue'>any</span>): <span
		style='color:blue'>any</span>;</span></p>

<p class=MsoNormal><span lang=EN-US>This signature denotes that a function may
be passed as the parameter of the ‘$’ function. When a function is passed to
‘$’, the jQuery library will invoke that function when a DOM document is ready.
Because TypeScript supports overloading, tools can use TypeScript to show all
available function signatures with their documentation tips and to give the
correct documentation once a function has been called with a particular
signature.</span></p>

<p class=MsoNormal><span lang=EN-US>A typical client would not need to add any
additional typing but could just use a community-supplied typing to discover
(through statement completion with documentation tips) and verify (through
static checking) correct use of the library, as in the following screen shot.</span></p>

<p class=MsoNormal style='margin-left:36.0pt'><img width=471 height=244
												   id="Picture 7"
												   src="../TypeScript%20Language%20Specification_bestanden/image002.png"></p>

<p class=MsoNormal><span lang=EN-US>Section </span><span
		lang=EN-US>3.3</span><span lang=EN-US> provides additional information about
object types.</span></p>

<h2><a name="_Toc364255685"><span lang=EN-US>1.4<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Structural Subtyping</span></a></h2>

<p class=MsoNormal><span lang=EN-US>Object types are compared <i>structurally</i>.
For example, in the code fragment below, class ‘CPoint’ matches interface ‘Point’
because ‘CPoint’ has all of the required members of ‘Point’. A class may
optionally declare that it implements an interface, so that the compiler will
check the declaration for structural compatibility. The example also
illustrates that an object type can match the type inferred from an object
literal, as long as the object literal supplies all of the required members.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
		lang=EN-US style='color:black'>&nbsp;Point&nbsp;</span><span lang=EN-US>{<span
		style='color:teal'><br>
</span><span style='color:black'>&nbsp;&nbsp;&nbsp;&nbsp;x</span><span
		style='color:teal'>:</span><span style='color:black'>&nbsp;</span><span
		style='color:blue;background:white'>number</span>;<span style='color:teal'><br>
</span><span style='color:black'>&nbsp;&nbsp;&nbsp;&nbsp;y</span><span
		style='color:teal'>:</span><span style='color:black'>&nbsp;</span><span
		style='color:blue;background:white'>number</span>;<span style='color:teal'><br>
</span>}</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
		lang=EN-US style='color:black'>&nbsp;getX</span><span lang=EN-US>(<span
		style='color:black'>p</span><span style='color:teal'>:</span><span
		style='color:black'>&nbsp;Point</span>)<span style='color:black'>&nbsp;</span>{<span
		style='color:teal'><br>
</span><span style='color:black'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
		style='color:blue;background:white'>return</span><span style='color:black'>&nbsp;</span>p.x;<span
		style='color:teal'><br>
</span>}</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>class</span><span
		lang=EN-US style='color:black'>&nbsp;CPoint&nbsp;</span><span lang=EN-US>{<br>
    x: <span style='color:blue;background:white'>number</span>;<br>
    y: <span style='color:blue;background:white'>number</span>;<span
			style='color:teal'><br>
</span><span style='color:black'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
			style='color:blue;background:white'>constructor</span>(x:<span
			style='color:black'>&nbsp;</span><span style='color:blue;background:white'>number</span>,&nbsp;
y:<span style='color:black'>&nbsp;</span><span style='color:blue;background:
white'>number</span>)<span style='color:black'>&nbsp;</span>{<br>
        <span style='color:blue;background:white'>this</span>.x = x;<br>
        <span style='color:blue;background:white'>this</span>.y = y;<br>
    }<span style='color:teal'><br>
</span>}</span></p>

<p class=Code><span lang=EN-US style='color:black'>getX</span><span lang=EN-US>(<span
		style='color:blue;background:white'>new</span><span style='color:black'>&nbsp;CPoint</span>(<span
		style='color:#A31515'>0</span>,<span style='color:black'>&nbsp;</span><span
		style='color:#A31515'>0</span>));<span style='color:black'>&nbsp;&nbsp;</span><span
		style='color:green'>//&nbsp;Ok,&nbsp;fields&nbsp;match</span></span></p>

<p class=Code><span lang=EN-US style='color:black'>getX</span><span lang=EN-US>({&nbsp;x:<span
		style='color:black'>&nbsp;</span><span style='color:#A31515'>0</span>,&nbsp;y:<span
		style='color:black'>&nbsp;</span><span style='color:#A31515'>0</span>,&nbsp;color:<span
		style='color:black'>&nbsp;</span><span style='color:#A31515'>&quot;red&quot;</span><span
		style='color:black'>&nbsp;</span>});<span style='color:black'>&nbsp;&nbsp;</span><span
		style='color:green'>//&nbsp;Extra&nbsp;fields&nbsp;Ok</span></span></p>

<p class=Code><span lang=EN-US>getX({&nbsp;x:<span style='color:black'>&nbsp;</span><span
		style='color:#A31515'>0</span><span style='color:black'>&nbsp;</span>});<span
		style='color:black'>&nbsp;&nbsp;</span><span style='color:green'>//&nbsp;Error:&nbsp;supplied&nbsp;parameter&nbsp;does&nbsp;not&nbsp;match</span></span></p>

<p class=MsoNormal><span lang=EN-US>See Section </span><span
		lang=EN-US>3.8</span><span lang=EN-US> for more information about type
comparisons.</span></p>

<h2><a name="_Toc364255686"><span lang=EN-US>1.5<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Contextual Typing</span></a></h2>

<p class=MsoNormal><span lang=EN-US>Ordinarily, TypeScript type inference
proceeds “bottom-up”: from the leaves of an expression tree to its root. In the
following example, TypeScript infers ‘number’ as the return type of the
function ‘mul’ by flowing type information bottom up in the return expression.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
		lang=EN-US> mul(a: <span style='color:blue;background:white'>number</span>, b: <span
		style='color:blue;background:white'>number</span>) {<br>
    <span style='color:blue;background:white'>return</span> a * b;<br>
}</span></p>

<p class=MsoNormal><span lang=EN-US>For variables and parameters without a type
annotation or a default value, TypeScript infers type ‘any’, ensuring that
compilers do not need non-local information about a function’s call sites to
infer the function’s return type. Generally, this bottom-up approach provides programmers
with a clear intuition about the flow of type information.</span></p>

<p class=MsoNormal><span lang=EN-US>However, in some limited contexts,
inference proceeds “top-down” from the context of an expression. Where this
happens, it is called contextual typing. Contextual typing helps tools provide
excellent information when a programmer is using a type but may not know all of
the details of the type. For example, in the jQuery example, above, the
programmer supplies a function expression as the second parameter to the ‘get’
method. During typing of that expression, tools can assume that the type of the
function expression is as given in the ‘get’ signature and can provide a
template that includes parameter names and types.</span></p>

<p class=Code><span lang=EN-US>$.get(<span style='color:maroon;background:white'>&quot;http://mysite.org/divContent&quot;</span>,<br>
      <span style='color:blue;background:white'>function</span> (data) {<br>
          $(<span style='color:maroon;background:white'>&quot;div&quot;</span>).text(data); 
<span style='color:green'>// TypeScript infers data is a string</span><br>
      }<br>
);</span></p>

<p class=MsoNormal><span lang=EN-US>Contextual typing is also useful for
writing out object literals. As the programmer types the object literal, the
contextual type provides information that enables tools to provide completion
for object member names.</span></p>

<p class=MsoNormal><span lang=EN-US>Section </span><span
		lang=EN-US>4.18</span><span lang=EN-US> provides additional information about
contextually typed expressions.</span></p>

<h2><a name="_Toc364255687"><span lang=EN-US>1.6<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Classes</span></a></h2>

<p class=MsoNormal><span lang=EN-US>JavaScript practice has at least two common
design patterns: the module pattern and the class pattern. Roughly speaking,
the module pattern uses closures to hide names and to encapsulate private data,
while the class pattern uses prototype chains to implement many variations on
object-oriented inheritance mechanisms. Libraries such as ‘prototype.js’ are
typical of this practice.</span></p>

<p class=MsoNormal><span lang=EN-US>This section and the module section below
will show how TypeScript emits consistent, idiomatic JavaScript code to
implement classes and modules that are closely aligned with the current ES6
proposal. The goal of TypeScript’s translation is to emit exactly what a
programmer would type when implementing a class or module unaided by a tool.
This section will also describe how TypeScript infers a type for each class
declaration. We’ll start with a simple BankAccount class.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>class</span><span
		lang=EN-US> BankAccount {<br>
    balance = <span style='color:maroon;background:white'>0</span>;<br>
    deposit(credit: <span style='color:blue;background:white'>number</span>) {<br>
        <span style='color:blue;background:white'>this</span>.balance +=
credit;<br>
        <span style='color:blue;background:white'>return</span> <span
			style='color:blue;background:white'>this</span>.balance;<br>
    }<br>
}  </span></p>

<p class=MsoNormal><span lang=EN-US>This class generates the following
JavaScript code.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
		lang=EN-US> BankAccount = (<span style='color:blue;background:white'>function</span>
() {<br>
    <span style='color:blue;background:white'>function</span> BankAccount() {<br>
        <span style='color:blue;background:white'>this</span>.balance = <span
			style='color:maroon;background:white'>0</span>;<br>
    }<br>
    BankAccount.prototype.deposit = <span style='color:blue;background:white'>function</span>(credit)
{<br>
        <span style='color:blue;background:white'>this</span>.balance +=
credit;<br>
        <span style='color:blue;background:white'>return</span> <span
			style='color:blue;background:white'>this</span>.balance;<br>
    };<br>
    <span style='color:blue;background:white'>return</span> BankAccount;<br>
})();</span></p>

<p class=MsoNormal><span lang=EN-US>This TypeScript class declaration creates a
variable named ‘BankAccount’ whose value is the constructor function for
‘BankAccount’ instances. This declaration also creates an instance type of the
same name. If we were to write this type as an interface it would look like the
following.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
		lang=EN-US> BankAccount {<br>
    balance: <span style='color:blue;background:white'>number</span>;<br>
    deposit(credit: <span style='color:blue;background:white'>number</span>): <span
			style='color:blue;background:white'>number</span>;<br>
}</span></p>

<p class=MsoNormal><span lang=EN-US>If we were to write out the function type
declaration for the ‘BankAccount’ constructor variable, it would have the
following form.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
		lang=EN-US> BankAccount: <span style='color:blue;background:white'>new</span>()
=&gt; BankAccount;</span></p>

<p class=MsoNormal><span lang=EN-US>The function signature is prefixed with the
keyword ‘new’ indicating that the ‘BankAccount’ function must be called as a
constructor. It is possible for a function’s type to have both call and
constructor signatures. For example, the type of the built-in JavaScript Date
object includes both kinds of signatures.</span></p>

<p class=MsoNormal><span lang=EN-US>If we want to start our bank account with
an initial balance, we can add to the ‘BankAccount’ class a constructor
declaration.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>class</span><span
		lang=EN-US> BankAccount {<br>
    balance: <span style='color:blue;background:white'>number</span>;<br>
    <span style='color:blue;background:white'>constructor</span>(initially: <span
			style='color:blue;background:white'>number</span>) {<br>
        <span style='color:blue;background:white'>this</span>.balance =
initially;<br>
    }<br>
    deposit(credit: <span style='color:blue;background:white'>number</span>) {<br>
        <span style='color:blue;background:white'>this</span>.balance +=
credit;<br>
        <span style='color:blue;background:white'>return</span> <span
			style='color:blue;background:white'>this</span>.balance;<br>
    }<br>
}</span></p>

<p class=MsoNormal><span lang=EN-US>This version of the ‘BankAccount’ class
requires us to introduce a constructor parameter and then assign it to the ‘balance’
field. To simplify this common case, TypeScript accepts the following shorthand
syntax.</span></p>

<p class=Code><span lang=EN-US style='color:blue;background:white'>class</span><span
		lang=EN-US> BankAccount {<br>
    <span style='color:blue;background:white'>constructor</span>(<span
			style='color:blue;background:white'>public</span> balance: <span
			style='color:blue;background:white'>number</span>) {<br>
    }<br>
    deposit(credit: <span style='color:blue;background:white'>number</span>) {<br>
        <span style='color:blue;background:white'>this</span>.balance +=
credit;<br>
        <span style='color:blue;background:white'>return</span> <span
			style='color:blue;background:white'>this</span>.balance;<br>
    }<br>
}</span></p>

<p class=MsoNormal><span lang=EN-US>The ‘public’ keyword denotes that the
constructor parameter is to be retained as a field. Public is the default
visibility for class members, but a programmer can also specify private
visibility for a class member. Private visibility is a design-time construct;
it is enforced during static type checking but does not imply any runtime
enforcement.</span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript classes also support
inheritance, as in the following example.<i> </i></span></p>

<p class=Code><span lang=EN-US style='color:blue'>class</span><span lang=EN-US>&nbsp;CheckingAccount&nbsp;<span
		style='color:blue'>extends</span>&nbsp;BankAccount&nbsp;<span style='color:
teal'>{<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:blue'>constructor</span><span
		style='color:teal'>(</span>balance<span style='color:teal'>:</span>&nbsp;<span
		style='color:blue'>number</span><span style='color:teal'>)</span>&nbsp;<span
		style='color:teal'>{<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:blue'>super</span><span
		style='color:teal'>(</span>balance<span style='color:teal'>);<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:teal'>}<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;writeCheck<span style='color:teal'>(</span>debit<span
		style='color:teal'>:</span>&nbsp;<span style='color:blue'>number</span><span
		style='color:teal'>)</span>&nbsp;<span style='color:teal'>{<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:blue'>this</span><span
		style='color:teal'>.</span>balance&nbsp;<span style='color:teal'>-=</span>&nbsp;debit<span
		style='color:teal'>;<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:teal'>}<br>
}</span></span></p>

<p class=MsoNormal><span lang=EN-US>In this example, the class
‘CheckingAccount’ <i>derives</i> from class ‘BankAccount’. The constructor for
‘CheckingAccount’ calls the constructor for class ‘BankAccount’ using the
‘super’ keyword. In the emitted JavaScript code, the prototype of
‘CheckingAccount’ will chain to the prototype of ‘BankingAccount’. </span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript classes may also specify static
members. Static class members become properties of the class constructor. </span></p>

<p class=MsoNormal><span lang=EN-US>Section </span><span
		lang=EN-US>8</span><span lang=EN-US> provides additional information about
classes.</span></p>

<h2><a name="_Toc364255688"><span lang=EN-US>1.7<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Modules</span></a></h2>

<p class=MsoNormal><span lang=EN-US>Classes and interfaces support large-scale
JavaScript development by providing a mechanism for describing how to use a
software component that can be separated from that component’s implementation. TypeScript
enforces <i>encapsulation</i> of implementation in classes at design time (by
restricting use of private members), but cannot enforce encapsulation at
runtime because all object properties are accessible at runtime. Future
versions of JavaScript may provide <i>private names</i> which would enable
runtime enforcement of private members.</span></p>

<p class=MsoNormal><span lang=EN-US>In the current version of JavaScript, the
only way to enforce encapsulation at runtime is to use the module pattern:
encapsulate private fields and methods using closure variables. The module
pattern is a natural way to provide organizational structure and dynamic
loading options by drawing a boundary around a software component. A module can
also provide the ability to introduce namespaces, avoiding use of the global
namespace for most software components. </span></p>

<p class=MsoNormal><span lang=EN-US>The following example illustrates the
JavaScript module pattern.</span></p>

<p class=Code><span lang=EN-US style='color:teal'>(</span><span lang=EN-US
																style='color:blue'>function</span><span lang=EN-US style='color:teal'>(</span><span
		lang=EN-US>exports<span style='color:teal'>)</span>&nbsp;<span
		style='color:teal'>{<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:blue'>var</span>&nbsp;key&nbsp;<span
		style='color:teal'>=</span>&nbsp;generateSecretKey<span style='color:teal'>();<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:blue'>function </span>sendMessage<span
		style='color:teal'>(</span>message<span style='color:teal'>)</span>&nbsp;<span
		style='color:teal'>{<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendSecureMessage<span
		style='color:teal'>(</span>message<span style='color:teal'>,</span>&nbsp;key<span
		style='color:teal'>);<br>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:teal'>}<br>
    </span>exports.sendMessage = sendMessage;<span style='color:teal'><br>
})(</span>MessageModule<span style='color:teal'>);</span></span></p>

<p class=MsoNormal><span lang=EN-US>This example illustrates the two essential
elements of the module pattern: a <i>module closure</i> and a <i>module</i> <i>object</i>.
The module closure is a function that encapsulates the module’s implementation,
in this case the variable ‘key’ and the function ‘sendMessage’. The module
object contains the exported variables and functions of the module. Simple
modules may create and return the module object. The module above takes the
module object as a parameter, ‘exports’, and adds the ‘sendMessage’ property to
the module object. This <i>augmentation</i> approach simplifies dynamic loading
of modules and also supports separation of module code into multiple files.</span></p>

<p class=MsoNormal><span lang=EN-US>The example assumes that an outer lexical
scope defines the functions ‘generateSecretKey’ and ‘sendSecureMessage’; it also
assumes that the outer scope has assigned the module object to the variable
‘MessageModule’.</span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript modules provide a mechanism for
succinctly expressing the module pattern. In TypeScript, programmers can
combine the module pattern with the class pattern by nesting modules and classes
within an outer module. </span></p>

<p class=MsoNormal><span lang=EN-US>The following example shows the definition
and use of a simple module.</span></p>

<p class=Code><span lang=EN-US>module&nbsp;M&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;s&nbsp;=&nbsp;&quot;hello&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;export&nbsp;function&nbsp;f()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;s;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}</span></p>

<p class=Code><span lang=EN-US>M.f();<br>
M.s;&nbsp;&nbsp;<span style='color:green;background:white'>// Error, </span><span
			style='color:green'>s is not exported</span></span></p>

<p class=MsoNormal><span lang=EN-US>In this example, variable ‘s’ is a private
feature of the module, but function ‘f’ is exported from the module and
accessible to code outside of the module. If we were to describe the effect of
module ‘M’ in terms of interfaces and variables, we would write</span></p>

<p class=Code><span lang=EN-US>interface<span style='color:black'>&nbsp;M&nbsp;</span><span
		style='color:teal'>{<br>
</span><span style='color:black'>&nbsp;&nbsp;&nbsp;&nbsp;f</span><span
		style='color:teal'>():</span><span style='color:black'>&nbsp;</span>string<span
		style='color:teal'>;<br>
}</span></span></p>

<p class=Code><span lang=EN-US>var<span style='color:black'>&nbsp;M</span><span
		style='color:teal'>:</span><span style='color:black'>&nbsp;M</span><span
		style='color:teal'>;</span></span></p>

<p class=MsoNormal><span lang=EN-US>The interface ‘M’ summarizes the externally
visible behavior of module ‘M’. In this example, we can use the same name for
the interface as for the initialized variable because in TypeScript type names
and variable names do not conflict: each lexical scope contains a variable
declaration space and type declaration space (see Section </span><span lang=EN-US>2.3</span><span lang=EN-US> for more details).</span></p>

<p class=MsoNormal><span lang=EN-US>Module ‘M’ is an example of an <i>internal</i>
module, because it is nested within the <i>global</i> module (see Section </span><span lang=EN-US>9</span><span lang=EN-US> for more details). The TypeScript compiler
emits the following JavaScript code for this module.</span></p>

<p class=Code><span lang=EN-US style='color:blue'>var</span><span lang=EN-US>&nbsp;M;<br>
(<span style='color:blue'>function</span>(M)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:blue'>var</span>&nbsp;s&nbsp;=&nbsp;<span
			style='color:maroon'>&quot;hello&quot;</span>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:blue'>function</span>&nbsp;f()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:blue'>return</span>&nbsp;s;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;M.f&nbsp;=&nbsp;f;<br>
})(M||(M={}));</span></p>

<p class=MsoNormal><span lang=EN-US>In this case, the compiler assumes that the
module object resides in global variable ‘M’, which may or may not have been
initialized to the desired module object.</span></p>

<p class=MsoNormal><span lang=EN-US>TypeScript also supports <i>external</i>
modules, which are files that contain top-level <i>export</i> and <i>import </i>directives.
For this type of module the TypeScript compiler will emit code whose module closure
and module object implementation vary according to the specified dynamic
loading system, for example, the Asynchronous Module Definition system.</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

</div>

<span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:"Segoe UI","sans-serif"'><br
		clear=all style='page-break-before:right'>
</span>
