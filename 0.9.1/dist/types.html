<!DOCTYPE html>
<html>
<head>
	<meta http-equiv=Content-Type content="text/html; charset=utf8">
	<title></title>
	<link rel="stylesheet" href="css/style.css" type="text/css">
</head>
<body>

<li><a href="index.html">Index</a></li>
<li><a href="introduction.html">Introduction</a></li>
<li><a href="basic_concepts.html">Basic Concepts</a></li>
<li><a href="types.html">Types</a></li>
<li><a href="expressions.html">Expressions</a></li>
<li><a href="statements.html">Statements</a></li>
<li><a href="functions.html">Functions</a></li>
<li><a href="interfaces.html">Interfaces</a></li>
<li><a href="types.html">Types</a></li>
<li><a href="classes.html">Classes</a></li>
<li><a href="enum.html">Enums</a></li>
<li><a href="internal_modules.html">Internal Modules</a></li>
<li><a href="source_external_modules.html">Source Files and External Modules</a></li>
<li><a href="ambient.html">Ambients</a></li>
<li><a href="grammar.html">Grammar</a></li>

	<div class=WordSection5>
	
	<h1><a name="_Toc364255694"><span lang=EN-US>3<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Types</span></a></h1>
	
	<p class=MsoNormal><span lang=EN-US>TypeScript adds optional static types to
	JavaScript. Types are used to place static constraints on program entities such
	as functions, variables, and properties so that compilers and development tools
	can offer better verification and assistance during software development. TypeScript’s
	<i>static</i> compile-time type system closely models the <i>dynamic</i> run-time
	type system of JavaScript, allowing programmers to accurately express the type
	relationships that are expected to exist when their programs run and have those
	assumptions pre-validated by the TypeScript compiler. TypeScript’s type
	analysis occurs entirely at compile-time and adds no run-time overhead to
	program execution.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>All types in TypeScript are subtypes of a
	single top type called the Any type. The </span><span class=CodeFragment><span
			lang=EN-US>any</span></span><span lang=EN-US> keyword references this type. The
	Any type is the one type that can represent <i>any</i> JavaScript value with no
	constraints. All other types are categorized as <b><i>primitive types</i></b>, <b><i>object
			types</i></b>, or <b><i>type parameters</i></b>. These types introduce various
	static constraints on their values.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The primitive types are the Number, Boolean,
	String, Void, Null, and Undefined types along with user defined enum types. The
	</span><span class=CodeFragment><span lang=EN-US>number</span></span><span
			lang=EN-US>, </span><span class=CodeFragment><span lang=EN-US>boolean</span></span><span
			lang=EN-US>, </span><span class=CodeFragment><span lang=EN-US>string</span></span><span
			lang=EN-US>, and </span><span class=CodeFragment><span lang=EN-US>void</span></span><span
			lang=EN-US> keywords reference the Number, Boolean, String, and Void primitive
	types respectively. The Void type exists purely to indicate the absence of a
	value, such as in a function with no return value. It is not possible to
	explicitly reference the Null and Undefined types—only <i>values</i> of those
	types can be referenced, using the </span><span class=CodeFragment><span
			lang=EN-US>null</span></span><span lang=EN-US> and </span><span
			class=CodeFragment><span lang=EN-US>undefined</span></span><span lang=EN-US>
	literals.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The object types are all class, interface, array,
	and literal types. Class and interface types are introduced through class and
	interface declarations and are referenced by the name given to them in their
	declarations. Class and interface types may be <b><i>generic types</i></b>
	which have one or more type parameters. Literal types are written as object,
	array, function, or constructor type literals and are used to compose new types
	from other types.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Declarations of modules, classes, properties,
	functions, variables and other language entities associate types with those
	entities. The mechanism by which a type is formed and associated with a
	language entity depends on the particular kind of entity. For example, a module
	declaration associates the module with an anonymous type containing a set of
	properties corresponding to the exported variables and functions in the module,
	and a function declaration associates the function with an anonymous type
	containing a call signature corresponding to the parameters and return type of
	the function. Types can be associated with variables through explicit <b><i>type
			annotations</i></b>, such as</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> x: <span style='color:blue;background:white'>number</span>;</span></p>
	
	<p class=MsoNormal><span lang=EN-US>or through implicit <b><i>type inference</i></b>,
	as in</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> x = <span style='color:maroon;background:white'>1</span>;</span></p>
	
	<p class=MsoNormal><span lang=EN-US>which infers the type of ‘x’ to be the Number
	primitive type because that is the type of the value used to initialize ‘x’.</span></p>
	
	<h2><a name="_Toc364255695"><span lang=EN-US>3.1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>The Any Type</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>The Any type is used to represent any
	JavaScript value. A value of the Any type supports the same operations as a
	value in JavaScript and minimal static type checking is performed for
	operations on Any values. Specifically, properties of any name can be accessed
	through an Any value and Any values can be called as functions or constructors
	with any argument list.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The </span><span class=CodeFragment><span
			lang=EN-US>any</span></span><span lang=EN-US> keyword references the Any type. In
	general, in places where a type is not explicitly provided and TypeScript
	cannot infer one, the Any type is assumed.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The Any type is a supertype of all types.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Some examples:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> x: <span style='color:blue;background:white'>any</span>;            
	<span style='color:green;background:white'>// Explicitly typed</span><br>
	<span style='color:blue;background:white'>var</span> y;                  <span
				style='color:green;background:white'>// Same as y: any</span><br>
	<span style='color:blue;background:white'>var</span> z: { a; b; };       <span
				style='color:green;background:white'>// Same as z: { a: any; b: any; }</span></span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
			lang=EN-US> f(x) {         <span style='color:green;background:white'>// Same
	as f(x: any): void</span><br>
	    console.log(x);<br>
	}</span></p>
	
	<h2><a name="_Toc364255696"><span lang=EN-US>3.2<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Primitive Types</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>The primitive types are the Number, Boolean,
	String, Void, Null, and Undefined types and all user defined enum types.</span></p>
	
	<h3><a name="_Toc364255697"><span lang=EN-US>3.2.1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>The Number Type</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>The Number primitive type corresponds to
	the similarly named JavaScript primitive type and represents double-precision
	64-bit format IEEE 754 floating point values.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The </span><span class=CodeFragment><span
			lang=EN-US>number</span></span><span lang=EN-US> keyword references the Number primitive
	type and numeric literals may be used to write values of the Number primitive
	type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For purposes of determining type relationships
	(section </span><span lang=EN-US>3.8</span><span lang=EN-US>) and accessing
	properties (section </span><span lang=EN-US>4.10</span><span lang=EN-US>), the
	Number primitive type behaves as an object type with the same properties as the
	global interface type ‘Number’.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Some examples:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> x: <span style='color:blue;background:white'>number</span>;         
	<span style='color:green;background:white'>// Explicitly typed</span><br>
	<span style='color:blue;background:white'>var</span> y = <span
				style='color:maroon;background:white'>0</span>;              <span
				style='color:green;background:white'>// Same as y: number = 0</span><br>
	<span style='color:blue;background:white'>var</span> z = <span
				style='color:maroon;background:white'>123.456</span>;        <span
				style='color:green;background:white'>// Same as z: number = 123.456</span><br>
	<span style='color:blue;background:white'>var</span> s = z.toFixed(<span
				style='color:maroon;background:white'>2</span>);   <span style='color:green;
	background:white'>// Property of Number </span><span style='color:green'>interface</span></span></p>
	
	<h3><a name="_Toc364255698"><span lang=EN-US>3.2.2<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>The Boolean Type</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>The Boolean primitive type corresponds to
	the similarly named JavaScript primitive type and represents logical values
	that are either true or false.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The </span><span class=CodeFragment><span
			lang=EN-US>boolean</span></span><span lang=EN-US> keyword references the
	Boolean primitive type and the </span><span class=CodeFragment><span
			lang=EN-US>true</span></span><span lang=EN-US> and </span><span
			class=CodeFragment><span lang=EN-US>false</span></span><span lang=EN-US>
	literals reference the two Boolean truth values.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For purposes of determining type
	relationships (section </span><span lang=EN-US>3.8</span><span lang=EN-US>) and
	accessing properties (section </span><span lang=EN-US>4.10</span><span
			lang=EN-US>), the Boolean primitive type behaves as an object type with the
	same properties as the global interface type ‘Boolean’.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Some examples:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> b: <span style='color:blue;background:white'>boolean</span>;        
	<span style='color:green;background:white'>// Explicitly typed</span><br>
	<span style='color:blue;background:white'>var</span> yes = <span
				style='color:blue;background:white'>true</span>;         <span
				style='color:green;background:white'>// Same as yes: boolean = true</span><br>
	<span style='color:blue;background:white'>var</span> no = <span
				style='color:blue;background:white'>false</span>;         <span
				style='color:green;background:white'>// Same as no: boolean = false</span></span></p>
	
	<h3><a name="_Toc364255699"><span lang=EN-US>3.2.3<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>The String Type</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>The String primitive type corresponds to
	the similarly named JavaScript primitive type and represents sequences of
	characters stored as Unicode UTF-16 code units.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The </span><span class=CodeFragment><span
			lang=EN-US>string</span></span><span lang=EN-US> keyword references the String primitive
	type and string literals may be used to write values of the String primitive type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For purposes of determining type
	relationships (section </span><span lang=EN-US>3.8</span><span lang=EN-US>) and
	accessing properties (section </span><span lang=EN-US>4.10</span><span
			lang=EN-US>), the String primitive type behaves as an object type with the same
	properties as the global interface type ‘String’.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Some examples:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> s: <span style='color:blue;background:white'>string</span>;         
	<span style='color:green;background:white'>// Explicitly typed</span><br>
	<span style='color:blue;background:white'>var</span> empty = <span
				style='color:maroon;background:white'>&quot;&quot;</span>;         <span
				style='color:green;background:white'>// Same as empty: string = &quot;&quot;</span><br>
	<span style='color:blue;background:white'>var</span> abc = <span
				style='color:maroon;background:white'>'abc'</span>;        <span
				style='color:green;background:white'>// Same as abc: string = &quot;abc&quot;</span><br>
	<span style='color:blue;background:white'>var</span> c = abc.charAt(<span
				style='color:maroon;background:white'>2</span>);  <span style='color:green;
	background:white'>// Property of String </span><span style='color:green'>interface</span></span></p>
	
	<h3><a name="_Toc364255700"><span lang=EN-US>3.2.4<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>The Void Type</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>The Void type, referenced by the </span><span
			class=CodeFragment><span lang=EN-US>void</span></span><span lang=EN-US>
	keyword, represents the absence of a value and is used as the return type of
	functions with no return value.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The only possible values for the Void type
	are </span><span class=CodeFragment><span lang=EN-US>null</span></span><span
			lang=EN-US> and </span><span class=CodeFragment><span lang=EN-US>undefined</span></span><span
			lang=EN-US>. The Void type is a subtype of the Any type and a supertype of the Null
	and Undefined types, but otherwise Void is unrelated to all other types.</span></p>
	
	<p class=MsoNormal><i><span lang=EN-US>NOTE: We might consider disallowing
	declaring variables of type Void as they serve no useful purpose. However,
	because Void is permitted as a type argument to a generic type or function it
	is not feasible to disallow Void properties or parameters.</span></i></p>
	
	<h3><a name="_Toc364255701"><span lang=EN-US>3.2.5<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>The Null Type</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>The Null type corresponds to the similarly
	named JavaScript primitive type and is the type of the </span><span
			class=CodeFragment><span lang=EN-US>null</span></span><span lang=EN-US> literal.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The </span><span class=CodeFragment><span
			lang=EN-US>null</span></span><span lang=EN-US> literal references the one and
	only value of the Null type. It is not possible to directly reference the Null
	type itself.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The Null type is a subtype of all types, except
	the Undefined type. This means that </span><span class=CodeFragment><span
			lang=EN-US>null</span></span><span lang=EN-US> is considered a valid value for
	all primitive types, object types, and type parameters, including even the
	Number and Boolean primitive types.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Some examples:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> n: <span style='color:blue;background:white'>number</span> = <span
			style='color:blue;background:white'>null</span>;   <span style='color:green;
	background:white'>// Primitives can be null</span><br>
	<span style='color:blue;background:white'>var</span> x = <span
				style='color:blue;background:white'>null</span>;           <span
				style='color:green;background:white'>// Same as x: any = null</span><br>
	<span style='color:blue;background:white'>var</span> e: Null;            <span
				style='color:green;background:white'>// Error, can't reference Null type</span></span></p>
	
	<h3><a name="_Toc364255702"></a><a name="_Ref331509340"><span lang=EN-US>3.2.6<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>The Undefined Type</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>The Undefined type corresponds to the
	similarly named JavaScript primitive type and is the type of the </span><span
			class=CodeFragment><span lang=EN-US>undefined</span></span><span lang=EN-US> literal.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The </span><span class=CodeFragment><span
			lang=EN-US>undefined</span></span><span lang=EN-US> literal denotes the value
	given to all uninitialized variables and is the one and only value of the
	Undefined type. It is not possible to directly reference the Undefined type
	itself.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The undefined type is a subtype of all
	types. This means that </span><span class=CodeFragment><span lang=EN-US>undefined</span></span><span
			lang=EN-US> is considered a valid value for all primitive types, object types,
	and type parameters.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Some examples:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> n: <span style='color:blue;background:white'>number</span>;         
	<span style='color:green;background:white'>// Same as n: number = undefined</span><br>
	<span style='color:blue;background:white'>var</span> x = undefined;      <span
				style='color:green;background:white'>// Same as x: any = undefined</span><br>
	<span style='color:blue;background:white'>var</span> e: Undefined;       <span
				style='color:green;background:white'>// Error, can't reference Undefined type</span></span></p>
	
	<h3><a name="_Toc364255703"><span lang=EN-US>3.2.7<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Enum Types</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Enum types are distinct user defined
	subtypes of the Number primitive type. Enum types are declared using enum
	declarations (section </span><span lang=EN-US>9.1</span><span lang=EN-US>) and
	referenced using type references (section </span><span
			lang=EN-US>3.6.2</span><span lang=EN-US>).</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Enum types are assignable to the Number
	primitive type, and vice versa, but different enum types are not assignable to
	each other.</span></p>
	
	<h3><a name="_Toc364255704"></a><a name="_Ref352158837"><span lang=EN-US>3.2.8<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>String Literal Types</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Specialized signatures (section </span><span lang=EN-US>3.7.2.4</span><span lang=EN-US>) permit string literals to be used as
	types in parameter type annotations. String literal types are permitted only in
	that context and nowhere else.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>All string literal types are subtypes of
	the String primitive type.</span></p>
	
	<h2><a name="_Toc364255705"></a><a name="_Ref325637319"><span lang=EN-US>3.3<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Object Types</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>The object types include references to class
	and interface types as well as anonymous object types created by a number of
	constructs such as object literals, function declarations, and module
	declarations. Object types are composed from properties, call signatures,
	construct signatures, and index signatures, collectively called members.</span></p>
	
	<h3><a name="_Toc364255706"></a><a name="_Ref349911330"><span lang=EN-US>3.3.1<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Named Type References</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Type references (section </span><span lang=EN-US>3.6.2</span><span lang=EN-US>) to class and interface types are
	classified as object types. Type references to generic class and interface
	types include type arguments that are substituted for the type parameters of
	the class or interface to produce an actual object type.</span></p>
	
	<h3><a name="_Toc364255707"><span lang=EN-US>3.3.2<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Array Types</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Array types represent JavaScript arrays.
	Array types are type references (section </span><span
			lang=EN-US>3.6.2</span><span lang=EN-US>) created from the generic interface
	type ‘Array’ in the global module. Array type literals (section </span><span lang=EN-US>3.6.4</span><span lang=EN-US>) provide a shorthand notation for
	creating such references.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Array literals (section </span><span lang=EN-US>4.6</span><span lang=EN-US>) may be used to create values of array
	types.</span></p>
	
	<h3><a name="_Toc364255708"><span lang=EN-US>3.3.3<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Anonymous Types</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Several constructs in the TypeScript
	language introduce new anonymous object types:</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Function and constructor type literals (section </span><span lang=EN-US>3.6.4</span><span lang=EN-US>).</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Object type literals (section </span><span lang=EN-US>3.7</span><span lang=EN-US>).</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Object literals (section </span><span lang=EN-US>4.5</span><span lang=EN-US>).</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Function expressions (section </span><span lang=EN-US>4.9</span><span lang=EN-US>) and function declarations (</span><span lang=EN-US>6.1</span><span lang=EN-US>).</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Constructor function types created by class
	declarations (section </span><span lang=EN-US>8.2.5</span><span lang=EN-US>).</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Module instance types created by module
	declarations (section </span><span lang=EN-US>10.3</span><span lang=EN-US>).</span></p>
	
	<h3><a name="_Toc364255709"><span lang=EN-US>3.3.4<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Members</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Every object type is composed from zero or
	more of the following kinds of members:</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><b><i><span lang=EN-US>Properties</span></i></b><span lang=EN-US>,
	which define the names and types of the properties of objects of the given
	type. Property names are unique within their type.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><b><i><span lang=EN-US>Call signatures</span></i></b><span
			lang=EN-US>, which define the possible parameter lists and return types
	associated with applying call operations to objects of the given type.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><b><i><span lang=EN-US>Construct signatures</span></i></b><span
			lang=EN-US>, which define the possible parameter lists and return types
	associated with applying the </span><span class=CodeFragment><span lang=EN-US>new</span></span><span
			lang=EN-US> operator to objects of the given type.</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><b><i><span lang=EN-US>Index signatures</span></i></b><span
			lang=EN-US>, which define type constraints for properties in the given type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Properties are either <b><i>public</i></b>
	or <b><i>private</i></b> and are either <b><i>required</i></b> or <b><i>optional</i></b>:</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Properties in a class declaration may be
	designated public or private, while properties declared in other contexts are
	always considered public. Private members are only accessible within the class
	body containing their declaration, as described in section </span><span lang=EN-US>8.2.2</span><span lang=EN-US>, and private properties match only
	themselves in subtype and assignment compatibility checks, as described in
	section </span><span lang=EN-US>3.8</span><span lang=EN-US>.</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Properties in an object type literal or
	interface declaration may be designated required or optional, while properties declared
	in other contexts are always considered required. Properties that are optional
	in the target type of an assignment may be omitted from source objects, as
	described in section </span><span lang=EN-US>3.8.3</span><span lang=EN-US>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Call and construct signatures may be <b><i>specialized</i></b>
	(section </span><span lang=EN-US>3.7.2.4</span><span lang=EN-US>) by including
	parameters with string literal types. Specialized signatures are used to
	express patterns where specific string values for some parameters cause the
	types of other parameters or the function result to become further specialized.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For purposes of determining type
	relationships (section </span><span lang=EN-US>3.8</span><span lang=EN-US>) and
	accessing properties (section </span><span lang=EN-US>4.10</span><span
			lang=EN-US>), object types appear to have certain additional members:</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Every object type appears to have the members of
	the global interface type ‘Object’ unless those members are hidden by members in
	the object type.</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>An object type with one or more call or
	construct signatures appears to have the members of the global interface type ‘Function’
	unless those members are hidden by members in the object type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Object type members hide ‘Object’ or ‘Function’
	interface members in the following manner:</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>A property hides an ‘Object’ or ‘Function’
	property with the same name.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>A call signature hides an ‘Object’ or ‘Function’
	call signature with the same number of parameters and identical parameter types
	in the respective positions.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>A construct signature hides an ‘Object’ or ‘Function’
	construct signature with the same number of parameters and identical parameter
	types in the respective positions.</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>An index signature hides an ‘Object’ or ‘Function’
	index signature with the same parameter type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>In effect, object types are subtypes of the
	‘Object’ or ‘Function’ interface unless the object types define members that
	are incompatible with those of the ‘Object’ or ‘Function’ interface—which, for
	example, occurs if an object type defines a property with the same name as a
	property in the ‘Object’ or ‘Function’ interface but with a type that isn’t a
	subtype of that in the ‘Object’ or ‘Function’ interface.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Some examples:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> o: Object = { x: <span style='color:maroon;background:white'>10</span>,
	y: <span style='color:maroon;background:white'>20</span> };         <span
				style='color:green;background:white'>// Ok</span><br>
	<span style='color:blue;background:white'>var</span> f: Function = (x: <span
				style='color:blue;background:white'>number</span>) =&gt; x * x;   <span
				style='color:green;background:white'>// Ok</span><br>
	<span style='color:blue;background:white'>var</span> err: Object = { toString: <span
				style='color:maroon;background:white'>0</span> };        <span
				style='color:green;background:white'>// Error, incompatible toString</span></span></p>
	
	<h2><a name="_Toc364255710"></a><a name="_Ref342394865"><span lang=EN-US>3.4<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Type Parameters</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>A type parameter represents an actual type
	that the parameter is bound to in a generic type reference or a generic
	function call. Type parameters have constraints that establish upper bounds for
	their actual type arguments.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Since a type parameter represents a
	multitude of different type arguments, type parameters have certain
	restrictions compared to other types. In particular, a type parameter cannot be
	used as a base class or interface.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For purposes of determining type
	relationships (section </span><span lang=EN-US>3.8</span><span lang=EN-US>),
	type parameters appear to be subtypes of the constraint specified in their
	declaration (or subtypes of ‘Object’ when no constraint was specified).
	Likewise, for purposes of accessing properties (section </span><span lang=EN-US>4.10</span><span lang=EN-US>), type parameters appear to have the
	members of their declared constraint, but no other members.</span></p>
	
	<h2><a name="_Toc364255711"></a><a name="_Ref349736654"><span lang=EN-US>3.5<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Named Types</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>Class, interface, and enum types are <b><i>named
		types</i></b> that are introduced through class declarations (section </span><span lang=EN-US>8.1</span><span lang=EN-US>), interface declarations (section </span><span lang=EN-US>7.1</span><span lang=EN-US>), and enum declarations (</span><span lang=EN-US>9.1</span><span lang=EN-US>). Class and interface types may have type
	parameters and are then called <b><i>generic types</i></b>. Conversely, named
	types without type parameters are called <b><i>non-generic types</i></b>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Interface declarations only introduce named
	types, whereas class declarations introduce named types <i>and</i> constructor
	functions that create instances of implementations of those named types. The
	named types introduced by class and interface declarations have only minor
	differences (classes can’t declare optional members and interfaces can’t declare
	private members) and are in most contexts interchangeable. In particular, class
	declarations with only public members introduce named types that function
	exactly like those created by interface declarations.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Named types are referenced through <b><i>type
		references</i></b> (section </span><span lang=EN-US>3.6.2</span><span
			lang=EN-US>) that specify a type name and, if applicable, the type arguments to
	be substituted for the type parameters of the named type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Named types are technically not types—only <i>references</i>
	to named types are. This distinction is particularly evident with generic
	types: Generic types are “templates” from which multiple <i>actual</i> types can
	be created by writing type references that supply type arguments to substitute
	in place of the generic type’s type parameters. Only once this substitution
	takes place does a generic type denote an actual type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US style='background:white'>TypeScript has a
	structural type system, and therefore a type created from a reference to a
	generic type is indistinguishable from an equivalent manually written expansion.
	For example, given the declaration</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US style='background:white'> Pair&lt;T1, T2&gt; { first: T1; second:
	T2; }</span></p>
	
	<p class=MsoNormal><span lang=EN-US style='background:white'>the type reference</span></p>
	
	<p class=Code><span lang=EN-US style='background:white'>Pair&lt;<span
			style='color:blue'>string</span>, Entity&gt;</span></p>
	
	<p class=MsoNormal><span lang=EN-US style='background:white'>is
	indistinguishable from the type</span></p>
	
	<p class=Code><span lang=EN-US style='background:white'>{ first: <span
			style='color:blue'>string</span>; second: Entity; }</span></p>
	
	<h3><a name="_Toc364255712"></a><a name="_Ref343772601"><span lang=EN-US>3.5.1<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Type Parameter Lists</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Class, interface, and function declarations
	may optionally include lists of type parameters enclosed in &lt; and &gt;
	brackets. Type parameters are also permitted in call signatures of object,
	function, and constructor type literals.</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeParameters:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>&lt;</span></span><span
			lang=EN-US>   TypeParameterList   </span><span class=Terminal><span lang=EN-US
																				style='font-style:normal'>&gt;</span></span></p>
	
	<p class=Grammar><span lang=EN-US>TypeParameterList:<br>
	TypeParameter<br>
	TypeParameterList   </span><span class=Terminal><span lang=EN-US
														  style='font-style:normal'>,</span></span><span lang=EN-US>   TypeParameter</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeParameter:<br>
	Identifier   Constraint<sub>opt</sub></span></p>
	
	<p class=Grammar><span lang=EN-US>Constraint:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>extends</span></span><span
			lang=EN-US>   Type</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Type parameter names must be unique. A
	compile-time error occurs if two or more type parameters in the same <span
				class=Production>TypeParameterList</span> have the same name.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The scope of a type parameter extends over
	the entire declaration with which the type parameter list is associated, the
	only exception being static member declarations in classes.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Each type parameter has an associated type
	parameter <b><i>constraint</i></b> that establishes an upper bound for type arguments:
	A type argument for a given type parameter must be assignable to the type
	specified in the type parameter constraint. Omitting a constraint corresponds
	to specifying the global interface type ‘Object’.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Type parameters may be referenced in type
	parameter constraints within the same type parameter list, including even
	constraint declarations that occur to the left of the type parameter.</span></p>
	
	<h3><a name="_Toc364255713"></a><a name="_Ref349725118"><span lang=EN-US>3.5.2<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Recursive Generic Types</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Generic types are permitted to directly or
	indirectly reference themselves in a recursive fashion as long as such
	references do not generate an infinite series of new types. Specifically,
	within a generic type <i>G</i> &lt; <i>T<sub>1</sub></i> , <i>T<sub>2</sub></i>
	, … , <i>T<sub>n</sub></i> &gt; and the types referenced by it, it is an error
	to reference <i>G</i> with a type argument that wraps any of <i>G</i>’s own
	type parameters (i.e. a type argument that wraps any <i>T<sub>x</sub></i>). A
	type parameter is said to be wrapped by a particular type when it is
	referenced, directly or indirectly, within that type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Consider the following example:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> List&lt;T&gt; {<br>
	    data: T;<br>
	    next: List&lt;T&gt;;<br>
	    owner: List&lt;List&lt;T&gt;&gt;;  <span style='color:green;background:
	white'>// Error, recursive reference with wrapped T</span><br>
	}</span></p>
	
	<p class=MsoNormal><span lang=EN-US>In the example the ‘owner’ property creates
	an infinite series of new types that wrap a ‘List&lt;T&gt;’ around each
	previous ‘List&lt;T&gt;’. Such generative recursion is prohibited by the rule
	above.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Note that it would be perfectly fine for
	the ‘owner’ property to have type ‘List&lt;List&lt;Object&gt;&gt;’ or any other
	type with a nested reference to ‘List’ that doesn’t reference ‘T’.</span></p>
	
	<p class=MsoNormal><i><span lang=EN-US>TODO: The restriction on generative
	recursion is likely to be removed.</span></i></p>
	
	<h3><a name="_Toc364255714"></a><a name="_Ref349832418"><span lang=EN-US>3.5.3<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Instance Types</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Each named type has an associated actual
	type known as the <b><i>instance type</i></b>. For a non-generic type, the
	instance type is simply a type reference to the non-generic type. For a generic
	type, the instance type is formed by creating a type reference from the generic
	type where each of the supplied type arguments is the corresponding type
	parameter. Since the instance type uses the type parameters it can be used only
	where the type parameters are in scope—that is, inside the declaration of the
	generic type. Within the constructor and member functions of a class, the type
	of </span><span class=CodeFragment><span lang=EN-US>this</span></span><span
			lang=EN-US> is the instance type of the class.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The following example illustrates the concept
	of an instance type:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>class</span><span
			lang=EN-US> G&lt;T&gt; {               <span style='color:green;background:
	white'>// </span><span style='color:green'>Introduce type parameter T</span><br>
	    self: G&lt;T&gt;;            <span style='color:green;background:white'>// </span><span
				style='color:green'>Use T as type argument to form instance type</span><br>
	    f() {<br>
	        <span style='color:blue;background:white'>this</span>.self = <span
				style='color:blue;background:white'>this</span>;  <span style='color:green;
	background:white'>// </span><span style='color:green'>self and this are both of
	type G&lt;T&gt;</span><br>
	    }<br>
	}</span></p>
	
	<h2><a name="_Toc364255715"></a><a name="_Ref319139856"><span lang=EN-US>3.6<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Specifying Types</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>Types are specified either by referencing
	their keyword or name, by querying expression types, or by writing type
	literals which compose other types into new types.</span></p>
	
	<p class=Grammar><span lang=EN-US>Type:<br>
	PredefinedType<br>
	TypeReference<br>
	TypeQuery<br>
	TypeLiteral</span></p>
	
	<h3><a name="_Toc364255716"></a><a name="_Ref352313823"><span lang=EN-US>3.6.1<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Predefined Types</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>The </span><span class=CodeFragment><span
			lang=EN-US>any</span></span><span lang=EN-US>, </span><span class=CodeFragment><span
			lang=EN-US>number</span></span><span lang=EN-US>, </span><span
			class=CodeFragment><span lang=EN-US>boolean</span></span><span lang=EN-US>, </span><span
			class=CodeFragment><span lang=EN-US>string</span></span><span lang=EN-US>, and </span><span
			class=CodeFragment><span lang=EN-US>void</span></span><span lang=EN-US>
	keywords reference the Any type and the Number, Boolean, String, and Void primitive
	types respectively.</span></p>
	
	<p class=Grammar><span lang=EN-US>PredefinedType:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>any</span></span><span
			lang=EN-US><br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>number<br>
	boolean</span></span><span lang=EN-US><br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>string<br>
	void</span></span></p>
	
	<p class=MsoNormal><span lang=EN-US>The predefined type keywords are reserved
	and cannot be used as names of user defined types.</span></p>
	
	<h3><a name="_Toc364255717"></a><a name="_Ref343176491"></a><a
			name="_Ref343165311"></a><a name="_Ref342558726"><span lang=EN-US>3.6.2<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Type </span></a><span lang=EN-US>References</span></h3>
	
	<p class=MsoNormal><span lang=EN-US>A type reference references a named type or
	type parameter through its name and, in the case of a generic type, supplies a
	type argument list.</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeReference:<br>
	TypeName   TypeArguments<sub>opt</sub></span></p>
	
	<p class=Grammar><span lang=EN-US>TypeName:<br>
	Identifier<br>
	ModuleName   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>.</span></span><span lang=EN-US>   Identifier</span></p>
	
	<p class=Grammar><span lang=EN-US>ModuleName:<br>
	Identifier<br>
	ModuleName   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>.</span></span><span lang=EN-US>   Identifier</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A <span class=Production>TypeReference</span>
	consists of a <span class=Production>TypeName</span> that a references a named
	type or type parameter. A reference to a generic type must be followed by a
	list of <span class=Production>TypeArguments</span>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Resolution of a <span class=Production>TypeName</span>
	consisting of a single identifier is described in section </span><span lang=EN-US>2.4</span><span lang=EN-US>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Resolution of a <span class=Production>TypeName</span>
	of the form <i>M.N</i>, where <i>M</i> is a <span class=Production>ModuleName</span>
	and <i>N</i> is an <span class=Production>Identifier</span>, proceeds by first
	resolving the module name <i>M</i>. If the resolution of <i>M</i> is successful
	and the resulting module contains an exported named type <i>N</i>, then <i>M.N</i>
	refers to that member. Otherwise, <i>M.N</i> is undefined.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Resolution of a <span class=Production>ModuleName</span>
	consisting of a single identifier is described in section </span><span lang=EN-US>2.4</span><span lang=EN-US>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Resolution of a <span class=Production>ModuleName</span>
	of the form <i>M.N</i>, where <i>M</i> is a <span class=Production>ModuleName</span>
	and <i>N</i> is an <span class=Production>Identifier</span>, proceeds by first
	resolving the module name <i>M</i>. If the resolution of <i>M</i> is successful
	and the resulting module contains an exported module member <i>N</i>, then <i>M.N</i>
	refers to that member. Otherwise, <i>M.N</i> is undefined.</span></p>
	
	<h4><span lang=EN-US>3.6.2.1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Type Arguments</span></h4>
	
	<p class=MsoNormal><span lang=EN-US>A type reference to a generic type must
	include a list of type arguments enclosed in angle brackets and separated by
	commas.</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeArguments:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>&lt;</span></span><span
			lang=EN-US>   TypeArgumentList   </span><span class=Terminal><span lang=EN-US
																			   style='font-style:normal'>&gt;</span></span></p>
	
	<p class=Grammar><span lang=EN-US>TypeArgumentList:<br>
	TypeArgument<br>
	TypeArgumentList   </span><span class=Terminal><span lang=EN-US
														 style='font-style:normal'>,</span></span><span lang=EN-US>   TypeArgument</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeArgument:<br>
	Type</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A type reference to a generic type is
	required to specify exactly one type argument for each type parameter of the
	referenced generic type. Each type argument must be assignable to (section </span><span lang=EN-US>3.8.3</span><span lang=EN-US>) the constraint of the corresponding
	type parameter or otherwise an error occurs. An example:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> A { a: <span style='color:blue;background:white'>string</span>; }</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> B <span style='color:blue;background:white'>extends</span> A { b: <span
			style='color:blue;background:white'>string</span>; }</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue'>interface</span><span
			lang=EN-US> C <span style='color:blue;background:white'>extends</span> B { c: <span
			style='color:blue;background:white'>string</span>; }</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> G&lt;T, U <span style='color:blue;background:white'>extends</span> B&gt;
	{<br>
	    x: T;<br>
	    y: U;<br>
	}</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> v1: G&lt;A, C&gt;;               <span style='color:green;
	background:white'>// Ok</span><br>
	<span style='color:blue;background:white'>var</span> v2: G&lt;{ a: <span
				style='color:blue;background:white'>string</span> }, C&gt;;   <span
				style='color:green;background:white'>// Ok, equivalent to G&lt;A, C&gt;</span><br>
	<span style='color:blue;background:white'>var</span> v3: G&lt;A, A&gt;;               <span
				style='color:green;background:white'>// Error, A not valid argument for U</span><span
				style='color:green'><br>
	</span><span style='color:blue;background:white'>var</span> v4: G&lt;G&lt;A, B&gt;,
	C&gt;;         <span style='color:green;background:white'>// Ok</span><br>
	<span style='color:blue;background:white'>var</span> v5: G&lt;<span
				style='color:blue;background:white'>any</span>, <span style='color:blue;
	background:white'>any</span>&gt;;           <span style='color:green;
	background:white'>// Ok</span><br>
	<span style='color:blue;background:white'>var</span> v6: G&lt;<span
				style='color:blue;background:white'>any</span>&gt;;                <span
				style='color:green;background:white'>// Error, wrong </span><span
				style='color:green'>number of arguments</span><br>
	<span style='color:blue;background:white'>var</span> v7: G;                     <span
				style='color:green;background:white'>// </span><span style='color:green'>Error,
	no arguments</span></span></p>
	
	<p class=MsoNormal><span lang=EN-US>A type argument is simply a <span
			class=Production>Type</span> and may itself be a type reference to a generic
	type, as demonstrated by ‘v4’ in the example above.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A type reference to a generic type <i>G</i>
	designates a type wherein all occurrences of <i>G</i>’s type parameters have
	been replaced with the actual type arguments supplied in the type reference.
	For example, the declaration of ‘v1’ above is equivalent to:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> v1: {<br>
	    x: { a: <span style='color:blue;background:white'>string</span>; }<br>
	    y: { a: <span style='color:blue;background:white'>string</span>; b: <span
				style='color:blue;background:white'>string</span>; c: <span style='color:blue;
	background:white'>string</span> };<br>
	};</span></p>
	
	<h3><a name="_Toc364255718"><span lang=EN-US>3.6.3<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Type Queries</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>A type query obtains the type of an
	expression.</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeQuery:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>typeof</span></span><span
			lang=EN-US>   TypeQueryExpression</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeQueryExpression:<br>
	Identifier<br>
	TypeQueryExpression   </span><span class=Terminal><span lang=EN-US
															style='font-style:normal'>.</span></span><span lang=EN-US>   IdentifierName</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A type query consists of the keyword </span><span
			class=CodeFragment><span lang=EN-US>typeof</span></span><span lang=EN-US>
	followed by an expression. The expression is restricted to a single identifier
	or a sequence of identifiers separated by periods. The expression is processed
	as an identifier expression (section </span><span
			lang=EN-US>4.3</span><span lang=EN-US>) or property access expression (section </span><span lang=EN-US>4.10</span><span lang=EN-US>), the type of which becomes the result.
	Similar to other static typing constructs, type queries are erased from the
	generated JavaScript code and add no run-time overhead.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Type queries are useful for capturing
	anonymous types that are generated by various constructs such as object
	literals, function declarations, and module declarations. For example:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> a = { x: 10, y: 20 };<br>
	<span style='color:blue;background:white'>var</span> b: <span style='color:
	blue;background:white'>typeof</span> a;</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Above, ‘b’ is given the same type as ‘a’,
	namely ‘{ x: number; y: number; }’.</span></p>
	
	<h3><a name="_Toc364255719"></a><a name="_Ref343720352"></a><a
			name="_Ref343718476"><span lang=EN-US>3.6.4<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Type Literals</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Type literals compose other types into new anonymous
	types.</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeLiteral:<br>
	ObjectType<br>
	ArrayType<br>
	FunctionType<br>
	ConstructorType</span></p>
	
	<p class=Grammar><span lang=EN-US>ArrayType:<br>
	PredefinedType   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>[</span></span><span lang=EN-US>   </span><span class=Terminal><span
			lang=EN-US style='font-style:normal'>]</span></span><span lang=EN-US> <br>
	TypeReference   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>[</span></span><span lang=EN-US>   </span><span class=Terminal><span
			lang=EN-US style='font-style:normal'>]</span></span><span lang=EN-US> <br>
	ObjectType   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>[</span></span><span lang=EN-US>   </span><span class=Terminal><span
			lang=EN-US style='font-style:normal'>]</span></span><span lang=EN-US> <br>
	ArrayType   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>[</span></span><span lang=EN-US>   </span><span class=Terminal><span
			lang=EN-US style='font-style:normal'>]</span></span></p>
	
	<p class=Grammar><span lang=EN-US>FunctionType:<br>
	TypeParameters<sub>opt</sub>   </span><span class=Terminal><span lang=EN-US
																	 style='font-style:normal'>(</span></span><span lang=EN-US>   ParameterList<sub>opt</sub>  
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>)</span></span><span
			lang=EN-US>   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>=&gt;</span></span><span lang=EN-US>   Type</span></p>
	
	<p class=Grammar><span lang=EN-US>ConstructorType:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>new</span></span><span
			lang=EN-US>   TypeParameters<sub>opt</sub>   </span><span class=Terminal><span
			lang=EN-US style='font-style:normal'>(</span></span><span lang=EN-US>  
	ParameterList<sub>opt</sub>   </span><span class=Terminal><span lang=EN-US
																	style='font-style:normal'>)</span></span><span lang=EN-US>   </span><span
			class=Terminal><span lang=EN-US style='font-style:normal'>=&gt;</span></span><span
			lang=EN-US>   Type</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Object type literals are the primary form
	of type literals and are described in section </span><span
			lang=EN-US>3.7</span><span lang=EN-US>. Array, function, and constructor type
	literals are simply shorthand notations for other types:</span></p>
	
	<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
		   style='margin-left:36.0pt;border-collapse:collapse;border:none'>
		<tr style='height:21.6pt'>
			<td width=271 style='width:202.95pt;border:solid windowtext 1.0pt;background:
	  #D9D9D9;padding:0cm 5.4pt 0cm 5.4pt;height:21.6pt'>
				<p class=MsoNormal align=center style='margin-bottom:0cm;margin-bottom:.0001pt;
	  text-align:center;line-height:normal;page-break-after:avoid'><span
						lang=EN-US>Type literal</span></p>
			</td>
			<td width=271 style='width:202.95pt;border:solid windowtext 1.0pt;border-left:
	  none;background:#D9D9D9;padding:0cm 5.4pt 0cm 5.4pt;height:21.6pt'>
				<p class=MsoNormal align=center style='margin-bottom:0cm;margin-bottom:.0001pt;
	  text-align:center;line-height:normal;page-break-after:avoid'><span
						lang=EN-US>Equivalent form</span></p>
			</td>
		</tr>
		<tr style='height:21.6pt'>
			<td width=271 style='width:202.95pt;border:solid windowtext 1.0pt;border-top:
	  none;padding:0cm 5.4pt 0cm 5.4pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal;page-break-after:avoid'><i><span lang=EN-US>T</span></i><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>[</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>]</span></span></p>
			</td>
			<td width=271 style='width:202.95pt;border-top:none;border-left:none;
	  border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
	  padding:0cm 5.4pt 0cm 5.4pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal;page-break-after:avoid'><span class=CodeFragment><span lang=EN-US>Array</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>&lt;</span></span><span
						lang=EN-US> <i>T</i> </span><span class=CodeFragment><span lang=EN-US>&gt;</span></span></p>
			</td>
		</tr>
		<tr style='height:21.6pt'>
			<td width=271 style='width:202.95pt;border:solid windowtext 1.0pt;border-top:
	  none;padding:0cm 5.4pt 0cm 5.4pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal;page-break-after:avoid'><span class=CodeFragment><span lang=EN-US>&lt;</span></span><span
						lang=EN-US> <i>TParams</i> </span><span class=CodeFragment><span lang=EN-US>&gt;</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>(</span></span><span
						lang=EN-US> <i>Params</i> </span><span class=CodeFragment><span lang=EN-US>)</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>=&gt;</span></span><span
						lang=EN-US> <i>Result</i></span></p>
			</td>
			<td width=271 style='width:202.95pt;border-top:none;border-left:none;
	  border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
	  padding:0cm 5.4pt 0cm 5.4pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal;page-break-after:avoid'><span class=CodeFragment><span lang=EN-US>{</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>&lt;</span></span><span
						lang=EN-US> <i>TParams</i> </span><span class=CodeFragment><span lang=EN-US>&gt;</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>(</span></span><span
						lang=EN-US> <i>Params</i> </span><span class=CodeFragment><span lang=EN-US>)</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>:</span></span><span
						lang=EN-US> <i>Result </i></span><span class=CodeFragment><span lang=EN-US>}</span></span></p>
			</td>
		</tr>
		<tr style='height:21.6pt'>
			<td width=271 style='width:202.95pt;border:solid windowtext 1.0pt;border-top:
	  none;padding:0cm 5.4pt 0cm 5.4pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal;page-break-after:avoid'><span class=CodeFragment><span lang=EN-US>new</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>&lt;</span></span><span
						lang=EN-US> <i>TParams</i> </span><span class=CodeFragment><span lang=EN-US>&gt;</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>(</span></span><span
						lang=EN-US> <i>Params</i> </span><span class=CodeFragment><span lang=EN-US>)</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>=&gt;</span></span><span
						lang=EN-US> <i>Result</i></span></p>
			</td>
			<td width=271 style='width:202.95pt;border-top:none;border-left:none;
	  border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
	  padding:0cm 5.4pt 0cm 5.4pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal;page-break-after:avoid'><span class=CodeFragment><span lang=EN-US>{</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>new</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>&lt;</span></span><span
						lang=EN-US> <i>TParams</i> </span><span class=CodeFragment><span lang=EN-US>&gt;</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>(</span></span><span
						lang=EN-US> <i>Params</i> </span><span class=CodeFragment><span lang=EN-US>)</span></span><span
						lang=EN-US> </span><span class=CodeFragment><span lang=EN-US>:</span></span><span
						lang=EN-US> <i>Result </i></span><span class=CodeFragment><span lang=EN-US>}</span></span></p>
			</td>
		</tr>
	</table>
	
	<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	12.0pt'><span lang=EN-US>&nbsp;</span></p>
	
	<p class=MsoNormal><span lang=EN-US>As the table above illustrates, an array
	type literal is shorthand for a reference to the generic interface type ‘Array’
	in the global module, a function type literal is shorthand for an object type
	containing a single call signature, and a constructor type literal is shorthand
	for an object type containing a single construct signature. Note that function
	and constructor types with multiple call or construct signatures cannot be
	written as function or constructor type literals but must instead be written as
	object type literals.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>In order to avoid grammar ambiguities,
	array type literals permit only a restricted set of notations for the element
	type. Specifically, an A<span class=Production>rrayType</span> cannot start
	with a <span class=Production>TypeQuery</span>, <span class=Production>FunctionType</span>,
	or <span class=Production>ConstructorType</span>. To use one of those forms for
	the element type, an array type must be written using the ‘Array&lt;T&gt;’
	notation. For example, the type</span></p>
	
	<p class=Code><span lang=EN-US>() =&gt; string[]</span></p>
	
	<p class=MsoNormal><span lang=EN-US>denotes a function returning a string
	array, not an array of functions returning string. The latter can be expressed
	using ‘Array&lt;T&gt;’ notation</span></p>
	
	<p class=Code><span lang=EN-US>Array&lt;() =&gt; string&gt;</span></p>
	
	<p class=MsoNormal><span lang=EN-US>or by writing the element type as an object
	type literal</span></p>
	
	<p class=Code><span lang=EN-US>{ (): string }[]</span></p>
	
	<h2><a name="_Toc364255720"></a><a name="_Ref343592676"><span lang=EN-US>3.7<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Object Type Literals</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>An object type literal defines an object
	type by specifying the set of members that are statically considered to be
	present in instances of the type. Object type literals can be given names using
	interface declarations but are otherwise anonymous.</span></p>
	
	<p class=Grammar><span lang=EN-US>ObjectType:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>{</span></span><span
			lang=EN-US>   TypeBody<sub>opt</sub>   </span><span class=Terminal><span
			lang=EN-US style='font-style:normal'>}</span></span></p>
	
	<p class=Grammar><span lang=EN-US>TypeBody:<br>
	TypeMemberList   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>;</span></span><sub><span lang=EN-US>opt</span></sub></p>
	
	<p class=Grammar><span lang=EN-US>TypeMemberList:<br>
	TypeMember<br>
	TypeMemberList   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>;</span></span><span lang=EN-US>   TypeMember</span></p>
	
	<p class=Grammar><span lang=EN-US>TypeMember:<br>
	PropertySignature<br>
	CallSignature<br>
	ConstructSignature<br>
	IndexSignature<br>
	MethodSignature</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The members of an object type literal are
	specified as a combination of property, call, construct, index, and method
	signatures. The signatures are separated by semicolons and enclosed in curly
	braces.</span></p>
	
	<h3><a name="_Toc364255721"><span lang=EN-US>3.7.1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Property Signatures</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>A property signature declares the name and
	type of a property member.</span></p>
	
	<p class=Grammar><span lang=EN-US>PropertySignature:<br>
	PropertyName   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>?</span></span><sub><span lang=EN-US>opt</span></sub><span lang=EN-US>  
	TypeAnnotation<sub>opt</sub></span></p>
	
	<p class=Grammar><span lang=EN-US>PropertyName:<br>
	IdentifierName<br>
	StringLiteral<br>
	NumericLiteral</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The <span class=Production>PropertyName</span>
	production, reproduced above from the ECMAScript grammar, permits a property
	name to be any identifier (including a reserved word), a string literal, or a numeric
	literal. String literals can be used to give properties names that are not
	valid identifiers, such as names containing blanks. Numeric literal property
	names are equivalent to string literal property names with the string
	representation of the numeric literal, as defined in the ECMAScript
	specification.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The <span class=Production>PropertyName</span>
	of a property signature must be unique within its containing type. If the property
	name is followed by a question mark, the property is optional. Otherwise, the
	property is required.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>If a property signature omits a <span
			class=Production>TypeAnnotation</span>, the Any type is assumed.</span></p>
	
	<h3><a name="_Toc364255722"></a><a name="_Ref343690028"><span lang=EN-US>3.7.2<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Call Signatures</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>A call signature defines the type
	parameters, parameter list, and return type associated with applying a call
	operation (section </span><span lang=EN-US>4.12</span><span lang=EN-US>) to an
	instance of the containing type. A type may <b><i>overload</i></b> call
	operations by defining multiple different call signatures.</span></p>
	
	<p class=Grammar><span lang=EN-US>CallSignature:<br>
	TypeParameters<sub>opt</sub>   </span><span class=Terminal><span lang=EN-US
																	 style='font-style:normal'>(</span></span><span lang=EN-US>   ParameterList<sub>opt</sub>  
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>)</span></span><span
			lang=EN-US>   TypeAnnotation<sub>opt</sub></span></p>
	
	<p class=MsoNormal><span lang=EN-US>A call signature that includes <span
			class=Production>TypeParameters</span> (section </span><span
			lang=EN-US>3.5.1</span><span lang=EN-US>) is called a <b><i>generic call
		signature</i></b>. Conversely, a call signature with no <span class=Production>TypeParameters</span>
	is called a non-generic call signature.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>As well as being members of object type
	literals, call signatures occur in method signatures (section </span><span lang=EN-US>3.7.5</span><span lang=EN-US>), function expressions (section </span><span lang=EN-US>4.9</span><span lang=EN-US>), and function declarations (section </span><span lang=EN-US>6.1</span><span lang=EN-US>).</span></p>
	
	<p class=MsoNormal><span lang=EN-US>An object type containing call signatures
	is said to be a <b><i>function type</i></b>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>It is an error for a type to declare
	multiple call signatures that are considered identical (section </span><span lang=EN-US>3.8.1</span><span lang=EN-US>) or differ only in their return types.</span></p>
	
	<h4><a name="_Ref343771118"><span lang=EN-US>3.7.2.1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Type Parameters</span></a></h4>
	
	<p class=MsoNormal><span lang=EN-US>Type parameters in call signatures provide
	a mechanism for expressing the relationships of parameter and return types in
	call operations. For example, a signature might introduce a type parameter and
	use it as both a parameter type and a return type, in effect describing a
	function that returns a value of the same type as its argument.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The scope of a type parameter extends over
	the entire call signature in which the type parameter is introduced. Thus, type
	parameters may be referenced in type parameter constraints, parameter types,
	and return type annotations in their associated call signature.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Type arguments for call signature type
	parameters may be explicitly specified in a call operation or may, when
	possible, be inferred (section </span><span
			lang=EN-US>4.12.2</span><span lang=EN-US>) from the types of the regular arguments
	in the call.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Some examples of call signatures with type
	parameters:</span></p>
	
	<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
		   style='margin-left:36.0pt;border-collapse:collapse;border:none'>
		<tr style='height:21.6pt'>
			<td width=277 style='width:207.9pt;border:solid windowtext 1.0pt;padding:
	  3.6pt 5.75pt 3.6pt 5.75pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal'><span class=CodeFragment><span lang=EN-US>&lt;T&gt;(x: T): T</span></span></p>
			</td>
			<td width=288 style='width:216.0pt;border:solid windowtext 1.0pt;border-left:
	  none;padding:3.6pt 5.75pt 3.6pt 5.75pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal'><span lang=EN-US>A function taking an argument of any type, returning
	  a value of that same type.</span></p>
			</td>
		</tr>
		<tr style='height:21.6pt'>
			<td width=277 style='width:207.9pt;border:solid windowtext 1.0pt;border-top:
	  none;padding:3.6pt 5.75pt 3.6pt 5.75pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal'><span class=CodeFragment><span lang=EN-US>&lt;T&gt;(x: T, y: T): T[]</span></span></p>
			</td>
			<td width=288 style='width:216.0pt;border-top:none;border-left:none;
	  border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
	  padding:3.6pt 5.75pt 3.6pt 5.75pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal'><span lang=EN-US>A function taking two values of the same type,
	  returning an array of that type.</span></p>
			</td>
		</tr>
		<tr style='height:21.6pt'>
			<td width=277 style='width:207.9pt;border:solid windowtext 1.0pt;border-top:
	  none;padding:3.6pt 5.75pt 3.6pt 5.75pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal'><span class=CodeFragment><span lang=EN-US>&lt;T, U&gt;(x: T, y: U): {
	  x: T; y: U; }</span></span></p>
			</td>
			<td width=288 style='width:216.0pt;border-top:none;border-left:none;
	  border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
	  padding:3.6pt 5.75pt 3.6pt 5.75pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal'><span lang=EN-US>A function taking two arguments of different types,
	  returning an object with properties ‘x’ and ‘y’ of those types.</span></p>
			</td>
		</tr>
		<tr style='height:21.6pt'>
			<td width=277 style='width:207.9pt;border:solid windowtext 1.0pt;border-top:
	  none;padding:3.6pt 5.75pt 3.6pt 5.75pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal'><span class=CodeFragment><span lang=EN-US>&lt;T, U&gt;(a: T[], f: (x:
	  T) =&gt; U): U[]</span></span></p>
			</td>
			<td width=288 style='width:216.0pt;border-top:none;border-left:none;
	  border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
	  padding:3.6pt 5.75pt 3.6pt 5.75pt;height:21.6pt'>
				<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	  normal'><span lang=EN-US>A function taking an array of one type and a
	  function argument, returning an array of another type, where the function
	  argument takes a value of the first array element type and returns a value of
	  the second array element type.</span></p>
			</td>
		</tr>
	</table>
	
	<p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
	12.0pt'><span lang=EN-US>&nbsp;</span></p>
	
	<h4><span lang=EN-US>3.7.2.2<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Parameter List</span></h4>
	
	<p class=MsoNormal><span lang=EN-US>A signature’s parameter list consists of
	zero or more required parameters, followed by zero or more optional parameters,
	finally followed by an optional rest parameter.</span></p>
	
	<p class=Grammar><span lang=EN-US>ParameterList:<br>
	RequiredParameterList<br>
	OptionalParameterList<br>
	RestParameter<br>
	RequiredParameterList   </span><span class=Terminal><span lang=EN-US
															  style='font-style:normal'>,</span></span><span lang=EN-US>  
	OptionalParameterList<br>
	RequiredParameterList   </span><span class=Terminal><span lang=EN-US
															  style='font-style:normal'>,</span></span><span lang=EN-US>   RestParameter<br>
	OptionalParameterList   </span><span class=Terminal><span lang=EN-US
															  style='font-style:normal'>,</span></span><span lang=EN-US>   RestParameter<br>
	RequiredParameterList   </span><span class=Terminal><span lang=EN-US
															  style='font-style:normal'>,</span></span><span lang=EN-US>  
	OptionalParameterList   </span><span class=Terminal><span lang=EN-US
															  style='font-style:normal'>,</span></span><span lang=EN-US>   RestParameter</span></p>
	
	<p class=Grammar><span lang=EN-US>RequiredParameterList:<br>
	RequiredParameter<br>
	RequiredParameterList   </span><span class=Terminal><span lang=EN-US
															  style='font-style:normal'>,</span></span><span lang=EN-US>   RequiredParameter</span></p>
	
	<p class=Grammar><span lang=EN-US>RequiredParameter:<br>
	PublicOrPrivate<sub>opt</sub>   Identifier   TypeAnnotation<sub>opt</sub><br>
	Identifier   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>:</span></span><span lang=EN-US>   StringLiteral</span></p>
	
	<p class=Grammar><span lang=EN-US>PublicOrPrivate:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>public</span></span><span
			lang=EN-US><br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>private</span></span></p>
	
	<p class=Grammar><span lang=EN-US>OptionalParameterList:<br>
	OptionalParameter<br>
	OptionalParameterList   </span><span class=Terminal><span lang=EN-US
															  style='font-style:normal'>,</span></span><span lang=EN-US>   OptionalParameter</span></p>
	
	<p class=Grammar><span lang=EN-US>OptionalParameter:<br>
	PublicOrPrivate<sub>opt</sub>   Identifier   </span><span class=Terminal><span
			lang=EN-US style='font-style:normal'>?</span></span><span lang=EN-US>  
	TypeAnnotation<sub>opt</sub><br>
	PublicOrPrivate<sub>opt</sub>   Identifier   TypeAnnotation<sub>opt</sub>  
	Initialiser</span></p>
	
	<p class=Grammar><span lang=EN-US>RestParameter:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>...</span></span><span
			lang=EN-US>   Identifier   TypeAnnotation<sub>opt</sub></span></p>
	
	<p class=MsoNormal><span lang=EN-US>Parameter names must be unique. A
	compile-time error occurs if two or more parameters have the same name.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A parameter is permitted to include a </span><span
			class=CodeFragment><span lang=EN-US>public</span></span><span lang=EN-US> or </span><span
			class=CodeFragment><span lang=EN-US>private</span></span><span lang=EN-US>
	modifier only if it occurs in the parameter list of a <span class=Production>ConstructorImplementation</span>
	(section </span><span lang=EN-US>8.3.1</span><span lang=EN-US>).</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A parameter with a type annotation is
	considered to be of that type. A type annotation for a rest parameter must
	denote an array type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A parameter with no type annotation or
	initializer is considered to be of type </span><span class=CodeFragment><span
			lang=EN-US>any</span></span><span lang=EN-US>, unless it is a rest parameter,
	in which case it is considered to be of type </span><span class=CodeFragment><span
			lang=EN-US>any[]</span></span><span lang=EN-US>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>When a parameter type annotation specifies
	a string literal type, the containing signature is a specialized signature
	(section </span><span lang=EN-US>3.7.2.4</span><span lang=EN-US>). Specialized
	signatures are not permitted in conjunction with a function body, i.e. the <span
				class=Production>FunctionExpression</span>, <span class=Production>FunctionImplementation</span>,
	<span class=Production>MemberFunctionImplementation</span>, and <span
				class=Production>ConstructorImplementation</span> grammar productions do not
	permit parameters with string literal types.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A parameter can be marked optional by
	following its name with a question mark (</span><span class=CodeFragment><span
			lang=EN-US>?</span></span><span lang=EN-US>) or by including an initializer.
	The form that includes an initializer is permitted only in conjunction with a
	function body, i.e. only in a <span class=Production>FunctionExpression</span>,
	<span class=Production>FunctionImplementation</span>, <span class=Production>MemberFunctionImplementation</span>,
	or <span class=Production>ConstructorImplementation</span> grammar production.</span></p>
	
	<p class=MsoNormal><i><span lang=EN-US>TODO: Rest parameters.</span></i></p>
	
	<h4><span lang=EN-US>3.7.2.3<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Return Type</span></h4>
	
	<p class=MsoNormal><span lang=EN-US>If present, a call signature’s return type
	annotation specifies the type of the value computed and returned by a call
	operation. A </span><span class=CodeFragment><span lang=EN-US>void</span></span><span
			lang=EN-US> return type annotation is used to indicate that a function has no
	return value.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>When a call signature with no return type
	annotation occurs in a context without a function body, the return type is assumed
	to be the Any type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>When a call signature with no return type
	annotation occurs in a context that has a function body (specifically, a
	function implementation, a member function implementation, or a member accessor
	declaration), the return type is inferred from the function body as described
	in section </span><span lang=EN-US>6.3</span><span lang=EN-US>.</span></p>
	
	<h4><a name="_Ref352141783"><span lang=EN-US>3.7.2.4<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Specialized Signatures</span></a></h4>
	
	<p class=MsoNormal><span lang=EN-US>When a parameter type annotation specifies
	a string literal type (section </span><span
			lang=EN-US>3.2.8</span><span lang=EN-US>), the containing signature is considered
	a specialized signature. Specialized signatures are used to express patterns
	where specific string values for some parameters cause the types of other parameters
	or the function result to become further specialized. For example, the
	declaration</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> Document {<br>
	    createElement(tagName: <span style='color:blue;background:white'>string</span>):
	HTMLElement;<br>
	    createElement(tagName: <span style='color:maroon;background:white'>&quot;div&quot;</span>):
	HTMLDivElement; <br>
	    createElement(tagName: <span style='color:maroon;background:white'>&quot;span&quot;</span>):
	HTMLSpanElement;<br>
	    createElement(tagName: <span style='color:maroon;background:white'>&quot;canvas&quot;</span>):
	HTMLCanvasElement;<br>
	}</span></p>
	
	<p class=MsoNormal><span lang=EN-US>states that calls to ‘createElement’ with
	the string literals “div”, “span”, and “canvas” return values of type
	‘HTMLDivElement’, ‘HTMLSpanElement’, and ‘HTMLCanvasElement’ respectively, and
	that calls with all other string expressions return values of type
	‘HTMLElement’. Because string literal types are subtypes of the String
	primitive type, when a function call argument matches a parameter of a string
	literal type in a specialized signature, the overload resolution rules (section
	</span><span lang=EN-US>4.12.1</span><span lang=EN-US>) give preference to that
	signature over a similar signature with a regular string parameter.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Every specialized call or construct signature
	in an object type must be a subtype of at least one non-specialized call or
	construct signature in the same object type. For example, the ‘createElement’
	property in the example above is of a type that contains three specialized
	signatures, all of which are subtypes of the non-specialized signature in the
	type.</span></p>
	
	<h3><a name="_Toc364255723"><span lang=EN-US>3.7.3<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Construct Signatures</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>A construct signature defines the parameter
	list and return type associated with applying the </span><span
			class=CodeFragment><span lang=EN-US>new</span></span><span lang=EN-US> operator
	(section </span><span lang=EN-US>4.11</span><span lang=EN-US>) to an instance
	of the containing type. A type may overload </span><span class=CodeFragment><span
			lang=EN-US>new</span></span><span lang=EN-US> operations by defining multiple construct
	signatures with different parameter lists.</span></p>
	
	<p class=Grammar><span lang=EN-US>ConstructSignature:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>new</span></span><span
			lang=EN-US>   TypeParameters<sub>opt</sub>   </span><span class=Terminal><span
			lang=EN-US style='font-style:normal'>(</span></span><span lang=EN-US>  
	ParameterList<sub>opt</sub>   </span><span class=Terminal><span lang=EN-US
																	style='font-style:normal'>)</span></span><span lang=EN-US>   TypeAnnotation<sub>opt</sub></span></p>
	
	<p class=MsoNormal><span lang=EN-US>The type parameters, parameter list, and
	return type of a construct signature are subject to the same rules as a call
	signature.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A type containing construct signatures is
	said to be a <b><i>constructor type</i></b>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>It is an error for a type to declare
	multiple construct signatures that are considered identical (section </span><span lang=EN-US>3.8.1</span><span lang=EN-US>) or differ only by their return types.</span></p>
	
	<h3><a name="_Toc364255724"></a><a name="_Ref351906593"></a><a
			name="_Ref351648322"><span lang=EN-US>3.7.4<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>Index Signatures</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>An index signature defines a type
	constraint for properties in the containing type.</span></p>
	
	<p class=Grammar><span lang=EN-US>IndexSignature:<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>[</span></span><span
			lang=EN-US>   Identifier   </span><span class=Terminal><span lang=EN-US
																		 style='font-style:normal'>:</span></span><span lang=EN-US>   </span><span
			class=Terminal><span lang=EN-US style='font-style:normal'>string</span></span><span
			lang=EN-US>   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>]</span></span><span lang=EN-US>   TypeAnnotation<br>
	</span><span class=Terminal><span lang=EN-US style='font-style:normal'>[</span></span><span
			lang=EN-US>   Identifier   </span><span class=Terminal><span lang=EN-US
																		 style='font-style:normal'>:</span></span><span lang=EN-US>   </span><span
			class=Terminal><span lang=EN-US style='font-style:normal'>number</span></span><span
			lang=EN-US>   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>]</span></span><span lang=EN-US>   TypeAnnotation</span></p>
	
	<p class=MsoNormal><span lang=EN-US>There are two kinds of index signatures:</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><b><i><span lang=EN-US>String index signatures</span></i></b><span
			lang=EN-US>, specified using index type </span><span class=CodeFragment><span
			lang=EN-US>string</span></span><span lang=EN-US>, define type constraints for
	all properties and numeric index signatures in the containing type.
	Specifically, in a type with a string index signature of type <i>T</i>, all
	properties and numeric index signatures must have types that are subtypes of <i>T</i>.</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><b><i><span lang=EN-US>Numeric index signatures</span></i></b><span
			lang=EN-US>, specified using index type </span><span class=CodeFragment><span
			lang=EN-US>number</span></span><span lang=EN-US>, define type constraints for
	all numerically named properties in the containing type. Specifically, in a
	type with a numeric index signature of type <i>T</i>, all numerically named
	properties must have types that are subtypes of <i>T</i>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A <b><i>numerically named property</i></b>
	is a property whose name is a valid numeric literal. Specifically, a property
	with a name <i>N</i> for which ToNumber(<i>N</i>) is not NaN, where ToNumber is
	the abstract operation defined in ECMAScript specification.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Index signatures affect the determination
	of the type that results from applying a bracket notation property access to an
	instance of the containing type, as described in section </span><span lang=EN-US>4.10</span><span lang=EN-US>.</span></p>
	
	<h3><a name="_Toc364255725"></a><a name="_Ref343599928"><span lang=EN-US>3.7.5<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Method Signatures</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>A method signature is shorthand for
	declaring a property of a function type.</span></p>
	
	<p class=Grammar><span lang=EN-US>MethodSignature:<br>
	PropertyName   </span><span class=Terminal><span lang=EN-US style='font-style:
	normal'>?</span></span><sub><span lang=EN-US>opt</span></sub><span lang=EN-US>  
	CallSignature</span></p>
	
	<p class=MsoNormal><span lang=EN-US>If the identifier is followed by a question
	mark, the property is optional. Otherwise, the property is required. Only object
	type literals and interfaces can declare optional properties.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A method signature of the form</span></p>
	
	<p class=Code><span class=CodeItalic><span lang=EN-US>PropName</span></span><span
			lang=EN-US> &lt; </span><span class=CodeItalic><span lang=EN-US>TypeParamList</span></span><span
			lang=EN-US> &gt; ( </span><span class=CodeItalic><span lang=EN-US>ParamList</span></span><span
			lang=EN-US> ) : </span><span class=CodeItalic><span lang=EN-US>ReturnType</span></span></p>
	
	<p class=MsoNormal><span lang=EN-US>is equivalent to the property declaration</span></p>
	
	<p class=Code><span class=CodeItalic><span lang=EN-US>PropName</span></span><span
			lang=EN-US> : { &lt; </span><span class=CodeItalic><span lang=EN-US>TypeParamList</span></span><span
			lang=EN-US> &gt; ( </span><span class=CodeItalic><span lang=EN-US>ParamList</span></span><span
			lang=EN-US> ) : </span><span class=CodeItalic><span lang=EN-US>ReturnType</span></span><span
			lang=EN-US> }</span></p>
	
	<p class=MsoNormal><span lang=EN-US>A literal type may <b><i>overload</i></b> a
	method by declaring multiple method signatures with the same name but differing
	parameter lists. Overloads must either all be required (question mark omitted)
	or all be optional (question mark included). A set of overloaded method
	signatures correspond to a declaration of a single property with a type
	composed from an equivalent set of call signatures. Specifically</span></p>
	
	<p class=Code><span class=CodeItalic><span lang=EN-US>PropName</span></span><span
			lang=EN-US> &lt; </span><span class=CodeItalic><span lang=EN-US>TypeParamList<sub>1</sub></span></span><span
			lang=EN-US> &gt; ( </span><span class=CodeItalic><span lang=EN-US>ParamList<sub>1</sub></span></span><span
			lang=EN-US> ) : </span><span class=CodeItalic><span lang=EN-US>ReturnType<sub>1</sub></span></span><span
			lang=EN-US> ;</span><span class=CodeItalic><span lang=EN-US><br>
	PropName</span></span><span lang=EN-US> &lt; </span><span class=CodeItalic><span
			lang=EN-US>TypeParamList<sub>2</sub></span></span><span lang=EN-US> &gt; ( </span><span
			class=CodeItalic><span lang=EN-US>ParamList<sub>2</sub></span></span><span
			lang=EN-US> ) : </span><span class=CodeItalic><span lang=EN-US>ReturnType<sub>2</sub></span></span><span
			lang=EN-US> ;<br>
	…</span><span class=CodeItalic><span lang=EN-US><br>
	PropName</span></span><span lang=EN-US> &lt; </span><span class=CodeItalic><span
			lang=EN-US>TypeParamList<sub>n</sub></span></span><span lang=EN-US> &gt; ( </span><span
			class=CodeItalic><span lang=EN-US>ParamList<sub>n</sub></span></span><span
			lang=EN-US> ) : </span><span class=CodeItalic><span lang=EN-US>ReturnType<sub>n</sub></span></span><span
			lang=EN-US> ;</span></p>
	
	<p class=MsoNormal><span lang=EN-US>is equivalent to</span></p>
	
	<p class=Code><span class=CodeItalic><span lang=EN-US>PropName</span></span><span
			lang=EN-US> : {<br>
	    &lt; </span><span class=CodeItalic><span lang=EN-US>TypeParamList<sub>1</sub></span></span><span
			lang=EN-US> &gt; ( </span><span class=CodeItalic><span lang=EN-US>ParamList<sub>1</sub></span></span><span
			lang=EN-US> ) : </span><span class=CodeItalic><span lang=EN-US>ReturnType<sub>1</sub></span></span><span
			lang=EN-US> ;<br>
	    &lt; </span><span class=CodeItalic><span lang=EN-US>TypeParamList<sub>2</sub></span></span><span
			lang=EN-US> &gt; ( </span><span class=CodeItalic><span lang=EN-US>ParamList<sub>2</sub></span></span><span
			lang=EN-US> ) : </span><span class=CodeItalic><span lang=EN-US>ReturnType<sub>2</sub></span></span><span
			lang=EN-US> ;<br>
	    …<br>
	    &lt; </span><span class=CodeItalic><span lang=EN-US>TypeParamList<sub>n</sub></span></span><span
			lang=EN-US> &gt; ( </span><span class=CodeItalic><span lang=EN-US>ParamList<sub>n</sub></span></span><span
			lang=EN-US> ) : </span><span class=CodeItalic><span lang=EN-US>ReturnType<sub>n</sub></span></span><span
			lang=EN-US> ; }</span></p>
	
	<p class=MsoNormal><span lang=EN-US>In the following example of an object type</span></p>
	
	<p class=Code><span lang=EN-US>{<br>
	    func1(x: <span style='color:blue;background:white'>number</span>): <span
				style='color:blue;background:white'>number</span>;         <span
				style='color:green;background:white'>// </span><span style='color:green'>Method
	signature</span><br>
	    func2: (x: <span style='color:blue;background:white'>number</span>) =&gt; <span
				style='color:blue;background:white'>number</span>;     <span style='color:green;
	background:white'>// </span><span style='color:green'>Function type literal</span><br>
	    func3: { (x: <span style='color:blue;background:white'>number</span>): <span
				style='color:blue;background:white'>number</span> };   <span style='color:green;
	background:white'>// </span><span style='color:green'>Object type literal</span><br>
	}</span></p>
	
	<p class=MsoNormal><span lang=EN-US>the properties ‘func1’, ‘func2’, and ‘func3’
	are all of the same type, namely an object type with a single call signature
	taking a number and returning a number. Likewise, in the object type</span></p>
	
	<p class=Code><span lang=EN-US>{<br>
	    func4(x: <span style='color:blue;background:white'>number</span>): <span
				style='color:blue;background:white'>number</span>;<br>
	    func4(s: <span style='color:blue;background:white'>string</span>): <span
				style='color:blue;background:white'>string</span>;<br>
	    func5: {<br>
	        (x: <span style='color:blue;background:white'>number</span>): <span
				style='color:blue;background:white'>number</span>;<br>
	        (s: <span style='color:blue;background:white'>string</span>): <span
				style='color:blue;background:white'>string</span>;<br>
	    };<br>
	}</span></p>
	
	<p class=MsoNormal><span lang=EN-US>the properties ‘func4’ and ‘func5’ are of
	the same type, namely an object type with two call signatures taking and
	returning number and string respectively.</span></p>
	
	<h2><a name="_Toc364255726"></a><a name="_Ref320780546"><span lang=EN-US>3.8<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Type Relationships</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>Types in TypeScript have identity, subtype,
	supertype, and assignment compatibility relationships as defined in the
	following sections.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For purposes of determining type
	relationships, all object types appear to have the members of the ‘Object’
	interface unless those members are hidden by members with the same name in the
	object types, and object types with one or more call or construct signatures appear
	to have the members of the ‘Function’ interface unless those members are hidden
	by members with the same name in the object types.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For purposes of determining subtype,
	supertype, and assignment compatibility relationships, the Number, Boolean, and
	String primitive types are treated as object types with the same properties as
	the ‘Number’, ‘Boolean’, and ‘String’ interfaces respectively. Likewise, enum
	types are treated as object types with the same properties as the ‘Number’
	interface.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>All type parameters appear to have the
	members of their constraint (or the ‘Object’ interface if they have no
	constraint), but no other members.</span></p>
	
	<h3><a name="_Ref307995639"></a><a name="_Toc364255727"></a><a
			name="_Ref326851506"><span lang=EN-US>3.8.1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>­Type and Member Identity</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Two types are considered <b><i>identical</i></b>
	when</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>they are the same primitive type,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>they are the same type parameter, or</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>they are object types with identical sets of
	members.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Two members are considered identical when</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>they are public properties with identical names,
	optionality, and types,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>they are private properties originating in the
	same declaration and having identical types,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>they are identical call signatures,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>they are identical construct signatures, or</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>they are index signatures of identical kind with
	identical types.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Two call or construct signatures are
	considered identical when they have the same number of type parameters and,
	considering those type parameters pairwise identical, have identical type
	parameter constraints, identical number of parameters of identical kinds and
	types, and identical return types.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Note that, except for primitive types and classes
	with private members, it is structure, not naming, of types that determines
	identity. Also, note that parameter names are not significant when determining
	identity of signatures.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Classes and interfaces can reference
	themselves in their internal structure, in effect creating recursive types with
	infinite nesting. For example, the type</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> A { next: A; }</span></p>
	
	<p class=MsoNormal><span lang=EN-US>contains an infinitely nested sequence of
	‘next’ properties. Types such as this are perfectly valid but require special
	treatment when determining type relationships. Specifically, when comparing references
	to two named types <i>S</i> and <i>T</i> for a given relationship (identity,
	subtype, or assignability), the relationship in question is assumed to be true
	for every directly or indirectly nested occurrence of references to the same <i>S</i>
	and <i>T</i> (where same means originating in the same declaration). For
	example, consider the identity relationship between ‘A’ above and ‘B’ below:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> B { next: C; }</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> C { next: D; }</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue'>interface</span><span
			lang=EN-US> D { next: B; }</span></p>
	
	<p class=MsoNormal><span lang=EN-US>To determine whether ‘A’ and ‘B’ are
	identical, first the ‘next’ properties of type ‘A’ and ‘C’ are compared. That
	leads to comparing the ‘next’ properties of type ‘A’ and ‘D’, which leads to
	comparing the ‘next’ properties of type ‘A’ and ‘B’. Since ‘A’ and ‘B’ are
	already being compared this relationship is by definition true. That in turn
	causes the other comparisons to be true, and therefore the final result is
	true.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>When this same technique is used to compare
	generic type references, two type references are considered the same when they
	originate in the same declaration and have identical type arguments. However,
	certain recursive generic patterns are prohibited, as explained in section </span><span lang=EN-US>3.5.2</span><span lang=EN-US>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Private properties match only if they originate
	in the same declaration and have identical types. Two distinct types might
	contain properties that originate in the same declaration if the types are separate
	parameterized references to the same generic class. In the example</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>class</span><span
			lang=EN-US> C&lt;T&gt; { <span style='color:blue;background:white'>private</span>
	x: T; }</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> X { f(): <span style='color:blue;background:white'>string</span>; }</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>interface</span><span
			lang=EN-US> Y { f(): <span style='color:blue;background:white'>string</span>; }</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> a: C&lt;X&gt;;<br>
	<span style='color:blue;background:white'>var</span> b: C&lt;Y&gt;;</span></p>
	
	<p class=MsoNormal><span lang=EN-US>the variables ‘a’ and ‘b’ are of identical
	types because the two type references to ‘C’ create types with a private member
	‘x’ that originates in the same declaration, and because the two private ‘x’
	members have types with identical sets of members once the type arguments ‘X’
	and ‘Y’ are substituted.</span></p>
	
	<h3><a name="_Toc364255728"></a><a name="_Ref326839674"><span lang=EN-US>3.8.2<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Subtypes and Supertypes</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Given a type <i>S</i> and a substitution
	type <i>S’</i> where</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>when <i>S</i> is the primitive type Number,
	Boolean, or String, <i>S’</i> is the global interface type ‘Number’, ‘Boolean’,
	or ‘String’,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>when <i>S</i> is an enum type, <i>S’</i> is the
	global interface type ‘Number’,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>when <i>S</i> is a type parameter, <i>S’</i> is
	the constraint of that type parameter,</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>otherwise, <i>S’</i> is <i>S</i>,</span></p>
	
	<p class=MsoNormal><i><span lang=EN-US>S</span></i><span lang=EN-US> is a <b><i>subtype</i></b>
	of a type <i>T</i>, and <i>T</i> is a <b><i>supertype</i></b> of <i>S</i>, if
	one of the following is true:</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> and <i>T</i>
	are identical types.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>T</span></i><span lang=EN-US> is the Any
	type.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> is the
	Undefined type.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> is the Null
	type and <i>T</i> is not the Undefined type.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> is an enum type
	and <i>T</i> is the primitive type Number.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> is a string
	literal type and <i>T</i> is the primitive type String.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> and <i>T</i>
	are type parameters, and <i>S</i> is directly or indirectly constrained to <i>T</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S’</span></i><span lang=EN-US> and <i>T</i> are
	object types and, for each member <i>M</i> in <i>T</i>, one of the following is
	true:</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a public property
	and <i>S’</i> contains a public property of the same name as <i>M</i> and a
	type that is a subtype of that of <i>M</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a private
	property and <i>S’</i> contains a private property that originates in the same
	declaration as <i>M</i> and has a type that is a subtype of that of <i>M</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is an optional
	property and <i>S’</i> contains no property of the same name as <i>M</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a non-specialized
	call or construct signature and <i>S’</i> contains a call or construct
	signature <i>N</i> where, when substituting ‘Object’ for all type parameters
	declared by <i>M</i> and <i>N</i> (if any),</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:108.0pt;text-indent:
	-18.0pt'><span lang=EN-US style='font-family:Wingdings'>§<span
			style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=EN-US>the
	signatures are of the same kind (call or construct),</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:108.0pt;text-indent:
	-18.0pt'><span lang=EN-US style='font-family:Wingdings'>§<span
			style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=EN-US>the
	number of non-optional parameters in <i>N</i> is less than or equal to that of <i>M</i>,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:108.0pt;text-indent:
	-18.0pt'><span lang=EN-US style='font-family:Wingdings'>§<span
			style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=EN-US>for
	parameter positions that are present in both signatures, each parameter type in
	<i>N</i> is a subtype or supertype of the corresponding parameter type in <i>M</i>,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:108.0pt;text-indent:
	-18.0pt'><span lang=EN-US style='font-family:Wingdings'>§<span
			style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=EN-US>the
	result type of <i>M</i> is Void, or the result type of <i>N</i> is a subtype of
	that of <i>M</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a string
	index signature of type <i>U</i> and <i>S’</i> contains a string index signature
	of a type that is a subtype of <i>U</i>.</span></p>
	
	<p class=MsoListParagraphCxSpLast style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a numeric
	index signature of type <i>U</i> and <i>S’</i> contains a string or numeric
	index signature of a type that is a subtype of <i>U</i>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>When comparing call or construct signatures,
	parameter names are ignored and rest parameters correspond to an unbounded
	expansion of optional parameters of the rest parameter element type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Note that specialized call and construct
	signatures (section </span><span lang=EN-US>3.7.2.4</span><span lang=EN-US>)
	are not significant when determining subtype and supertype relationships.</span></p>
	
	<h3><a name="_Toc364255729"></a><a name="_Ref330633611"><span lang=EN-US>3.8.3<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Assignment Compatibility</span></a></h3>
	
	<p class=MsoNormal><span lang=EN-US>Types are required to be assignment
	compatible in<a name="_Ref313351047"> certain circumstances, such as expression
			and variable types in assignment statements and argument and parameter types in
			function calls.</a></span></p>
	
	<p class=MsoNormal><span lang=EN-US>Given a type <i>S</i> and a substitution
	type <i>S’</i> where</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>when <i>S</i> is the primitive type Number,
	Boolean, or String, <i>S’</i> is the global interface type ‘Number’, ‘Boolean’,
	or ‘String’,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>when <i>S</i> is an enum type, <i>S’</i> is the
	global interface type ‘Number’,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>when <i>S</i> is a type parameter, <i>S’</i> is the
	constraint of that type parameter,</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>otherwise, <i>S’</i> is <i>S</i>,</span></p>
	
	<p class=MsoNormal><i><span lang=EN-US>S</span></i><span lang=EN-US> is <b><i>assignable
		to</i></b> a type <i>T</i>, and <i>T</i> is <b><i>assignable from</i></b> <i>S</i>,
	if one of the following is true:</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> and <i>T</i>
	are identical types.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> or <i>T</i> is
	the Any type.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> is the
	Undefined type.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> is the Null
	type and <i>T</i> is not the Undefined type.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> or <i>T</i> is
	an enum type and<i> </i>the other is the primitive type Number.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S</span></i><span lang=EN-US> and <i>T</i>
	are type parameters, and <i>S</i> is directly or indirectly constrained to <i>T</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>S’</span></i><span lang=EN-US> and <i>T</i>
	are object types and, for each member <i>M</i> in <i>T</i>, one of the
	following is true:</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a public
	property and <i>S’</i> contains a public property of the same name as <i>M</i>
	and a type that is assignable to that of <i>M</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a private
	property and <i>S’</i> contains a private property that originates in the same
	declaration as <i>M</i> and has a type that is assignable to that of <i>M</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is an optional
	property and <i>S’</i> contains no property of the same name as <i>M</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a non-specialized
	call or construct signature and <i>S’</i> contains a call or construct
	signature <i>N</i> where, when substituting ‘Object’ for all type parameters
	declared by <i>M</i> and <i>N</i> (if any),</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:108.0pt;text-indent:
	-18.0pt'><span lang=EN-US style='font-family:Wingdings'>§<span
			style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=EN-US>the
	signatures are of the same kind (call or construct),</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:108.0pt;text-indent:
	-18.0pt'><span lang=EN-US style='font-family:Wingdings'>§<span
			style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=EN-US>the
	number of non-optional parameters in <i>N</i> is less than or equal to that of <i>M</i>,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:108.0pt;text-indent:
	-18.0pt'><span lang=EN-US style='font-family:Wingdings'>§<span
			style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=EN-US>for
	parameter positions that are present in both signatures, each parameter type in
	<i>N</i> is assignable to or from the corresponding parameter type in <i>M</i>,</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:108.0pt;text-indent:
	-18.0pt'><span lang=EN-US style='font-family:Wingdings'>§<span
			style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=EN-US>the
	result type of <i>M</i> is Void, or the result type of <i>N</i> is assignable
	to that of <i>M</i>.</span></p>
	
	<p class=MsoListParagraphCxSpMiddle style='margin-left:72.0pt;text-indent:-18.0pt'><a
			name="_Ref315956176"><span lang=EN-US style='font-family:"Courier New"'>o<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><i><span
			lang=EN-US>M</span></i><span lang=EN-US> is a string index signature of type <i>U</i>
	and <i>S’</i> contains a string index signature of a type that is assignable to
	<i>U</i>.</span></a></p>
	
	<p class=MsoListParagraphCxSpLast style='margin-left:72.0pt;text-indent:-18.0pt'><span
			lang=EN-US style='font-family:"Courier New"'>o<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
	</span></span><i><span lang=EN-US>M</span></i><span lang=EN-US> is a numeric
	index signature of type <i>U</i> and <i>S’</i> contains a string or numeric
	index signature of a type that is assignable to <i>U</i>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>When comparing call or construct
	signatures, parameter names are ignored and rest parameters correspond to an
	unbounded expansion of optional parameters of the rest parameter element type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>Note that specialized call and construct
	signatures (section </span><span lang=EN-US>3.7.2.4</span><span lang=EN-US>)
	are not significant when determining assignment compatibility.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The assignment compatibility and subtyping
	rules differ only in that</span></p>
	
	<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><span
			lang=EN-US style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>the Any type is assignable to, but not a subtype
	of, all types, and</span></p>
	
	<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><span lang=EN-US
																		style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></span><span lang=EN-US>the primitive type Number is assignable to, but
	not a subtype of, all enum types.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The assignment compatibility rules imply
	that, when assigning values or passing parameters, optional properties must
	either be present and of a compatible type, or not be present at all. For
	example:</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>function</span><span
			lang=EN-US style='background:white'> foo(x: { id: <span style='color:blue'>number</span>;
	name?: <span style='color:blue'>string; </span>}) { }</span></p>
	
	<p class=Code><span lang=EN-US style='background:white'>foo({ id: <span
			style='color:maroon'>1234 </span>});                 <span style='color:green'>//
	Ok</span><br>
	foo({ id: <span style='color:maroon'>1234</span>, name: <span style='color:
	maroon'>&quot;hello&quot; </span>});  <span style='color:green'>// Ok</span><br>
	foo({ id: <span style='color:maroon'>1234</span>, name: <span style='color:
	blue'>false </span>});    <span style='color:green'>// Error, name of wrong
	type</span><br>
	foo({ name: <span style='color:maroon'>&quot;hello&quot; </span>});            <span
				style='color:green'>// Error, id required but missing</span></span></p>
	
	<h2><a name="_Toc364255730"></a><a name="_Ref331363661"><span lang=EN-US>3.9<span
			style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
			lang=EN-US>Widened Types</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>In several situations TypeScript infers
	types from context, alleviating the need for the programmer to explicitly
	specify types that appear obvious. For example</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> name = <span style='color:maroon;background:white'>&quot;Steve&quot;</span>;</span></p>
	
	<p class=MsoNormal><span lang=EN-US>infers the type of ‘name’ to be the String primitive
	type since that is the type of the value used to initialize it. When inferring
	the type of a variable, property or function result from an expression, the <b><i>widened</i></b>
	form of the source type is used as the inferred type of the target. The widened
	form of a type is the type in which all occurrences of the Null and Undefined
	types have been replaced with the type </span><span class=CodeFragment><span
			lang=EN-US>any</span></span><span lang=EN-US>.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>The following example shows the results of
	widening types to produce inferred variable types.</span></p>
	
	<p class=Code><span lang=EN-US style='color:blue;background:white'>var</span><span
			lang=EN-US> a = <span style='color:blue;background:white'>null</span>;                   
	<span style='color:green;background:white'>// var a: any</span><br>
	<span style='color:blue;background:white'>var</span> b =
	undefined;               <span style='color:green;background:white'>// var b:
	any</span><br>
	<span style='color:blue;background:white'>var</span> c = { x: <span
				style='color:maroon;background:white'>0</span>, y: <span style='color:blue;
	background:white'>null</span> };        <span style='color:green;background:
	white'>// var c: { x: number, y: any</span> <span style='color:green;
	background:white'>}</span><br>
	<span style='color:blue;background:white'>var</span> d = [ <span
				style='color:blue;background:white'>null</span>, undefined ];     <span
				style='color:green;background:white'>// var d: any[]</span></span></p>
	
	<h2><a name="_Toc364255731"></a><a name="_Ref314579145"><span lang=EN-US>3.10</span><span
			lang=EN-US>Best Common Type</span></a></h2>
	
	<p class=MsoNormal><span lang=EN-US>In some cases a <b><i>best common type</i></b>
	needs to be inferred from a set of types. In particular, return types of
	functions with multiple return statements and element types of array literals
	are found this way.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For an empty set of types, the best common
	type is the Any type.</span></p>
	
	<p class=MsoNormal><span lang=EN-US>For a non-empty set of types { <i>T<sub>1</sub></i>,
	<i>T<sub>2</sub></i>, …, <i>T<sub>n</sub></i> }, the best common type is the
	one <i>T<sub>x</sub></i> in the set that is a supertype of every <i>T<sub>n</sub></i>.
	It is possible that no such type exists, in which case the best common type is
	an empty object type (the type </span><span class=CodeFragment><span
			lang=EN-US>{}</span></span><span lang=EN-US>).</span></p>
	
	<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>
	
	</div>
	s
	


</body>
</html>
